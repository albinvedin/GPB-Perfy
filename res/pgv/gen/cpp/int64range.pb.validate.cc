// Code generated by protoc-gen-validate
// source: int64range.proto
// DO NOT EDIT!!!

#include "int64range.pb.validate.h"

#include <google/protobuf/message.h>
#include <google/protobuf/util/time_util.h>

namespace pgv {

namespace protobuf = google::protobuf;
namespace protobuf_wkt = google::protobuf;

namespace validate {
using std::string;

pgv::Validator<::pgv::Int64Range> validator___pgv__Int64Range(static_cast<bool(*)(const ::pgv::Int64Range&, pgv::ValidationMsg*)>(::pgv::Validate));


pgv::Validator<::pgv::FloatRange> validator___pgv__FloatRange(static_cast<bool(*)(const ::pgv::FloatRange&, pgv::ValidationMsg*)>(::pgv::Validate));


pgv::Validator<::pgv::DoubleRange> validator___pgv__DoubleRange(static_cast<bool(*)(const ::pgv::DoubleRange&, pgv::ValidationMsg*)>(::pgv::Validate));




} // namespace validate
} // namespace pgv


namespace pgv {


// Validate checks the field values on ::pgv::Int64Range with the rules defined
// in the proto definition for this message. If any rules are violated, the
// return value is false and an error message is written to the input string argument.

	

	

	
	
	

	
	
	

	



bool Validate(const ::pgv::Int64Range& m, pgv::ValidationMsg* err) {
	(void)m;
	(void)err;
	

	

	

	
		for (int i = 0; i < m.content().size(); i++) {
			const auto& item = m.content().Get(i);
			(void)item;

			

			
	
	

	
	
		
			
				if (item <= -100 || item >= 100) {
					{
std::ostringstream msg("invalid ");
msg << "Int64RangeValidationError" << "." << "Content";
msg << "[" << "i" << "]";
msg << ": " << "[\"value must be inside range (\" %!q(int64=-100) \", \" 'd' \")\"]";
*err = msg.str();
return false;
}
				}
			
		
	

	


		}
	

	return true;
}





// Validate checks the field values on ::pgv::FloatRange with the rules defined
// in the proto definition for this message. If any rules are violated, the
// return value is false and an error message is written to the input string argument.

	

	

	
	
	

	
	
	

	



bool Validate(const ::pgv::FloatRange& m, pgv::ValidationMsg* err) {
	(void)m;
	(void)err;
	

	

	

	
		for (int i = 0; i < m.content().size(); i++) {
			const auto& item = m.content().Get(i);
			(void)item;

			

			
	
	

	
	
		
			
				if (item <= -100 || item >= 100) {
					{
std::ostringstream msg("invalid ");
msg << "FloatRangeValidationError" << "." << "Content";
msg << "[" << "i" << "]";
msg << ": " << "[\"value must be inside range (\" %!q(float32=-100) \", \" %!q(float32=100) \")\"]";
*err = msg.str();
return false;
}
				}
			
		
	

	


		}
	

	return true;
}





// Validate checks the field values on ::pgv::DoubleRange with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	
	
	

	
	
	

	



bool Validate(const ::pgv::DoubleRange& m, pgv::ValidationMsg* err) {
	(void)m;
	(void)err;
	

	

	

	
		for (int i = 0; i < m.content().size(); i++) {
			const auto& item = m.content().Get(i);
			(void)item;

			

			
	
	

	
	
		
			
				if (item <= -100 || item >= 100) {
					{
std::ostringstream msg("invalid ");
msg << "DoubleRangeValidationError" << "." << "Content";
msg << "[" << "i" << "]";
msg << ": " << "[\"value must be inside range (\" %!q(float64=-100) \", \" %!q(float64=100) \")\"]";
*err = msg.str();
return false;
}
				}
			
		
	

	


		}
	

	return true;
}






} // namespace

