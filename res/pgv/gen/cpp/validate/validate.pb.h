// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: validate.proto

#ifndef PROTOBUF_validate_2eproto__INCLUDED
#define PROTOBUF_validate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
namespace validate {
class AnyRules;
class AnyRulesDefaultTypeInternal;
extern AnyRulesDefaultTypeInternal _AnyRules_default_instance_;
class BoolRules;
class BoolRulesDefaultTypeInternal;
extern BoolRulesDefaultTypeInternal _BoolRules_default_instance_;
class BytesRules;
class BytesRulesDefaultTypeInternal;
extern BytesRulesDefaultTypeInternal _BytesRules_default_instance_;
class DoubleRules;
class DoubleRulesDefaultTypeInternal;
extern DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;
class DurationRules;
class DurationRulesDefaultTypeInternal;
extern DurationRulesDefaultTypeInternal _DurationRules_default_instance_;
class EnumRules;
class EnumRulesDefaultTypeInternal;
extern EnumRulesDefaultTypeInternal _EnumRules_default_instance_;
class FieldRules;
class FieldRulesDefaultTypeInternal;
extern FieldRulesDefaultTypeInternal _FieldRules_default_instance_;
class Fixed32Rules;
class Fixed32RulesDefaultTypeInternal;
extern Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;
class Fixed64Rules;
class Fixed64RulesDefaultTypeInternal;
extern Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;
class FloatRules;
class FloatRulesDefaultTypeInternal;
extern FloatRulesDefaultTypeInternal _FloatRules_default_instance_;
class Int32Rules;
class Int32RulesDefaultTypeInternal;
extern Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;
class Int64Rules;
class Int64RulesDefaultTypeInternal;
extern Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;
class MapRules;
class MapRulesDefaultTypeInternal;
extern MapRulesDefaultTypeInternal _MapRules_default_instance_;
class MessageRules;
class MessageRulesDefaultTypeInternal;
extern MessageRulesDefaultTypeInternal _MessageRules_default_instance_;
class RepeatedRules;
class RepeatedRulesDefaultTypeInternal;
extern RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
class SFixed32Rules;
class SFixed32RulesDefaultTypeInternal;
extern SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;
class SFixed64Rules;
class SFixed64RulesDefaultTypeInternal;
extern SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;
class SInt32Rules;
class SInt32RulesDefaultTypeInternal;
extern SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;
class SInt64Rules;
class SInt64RulesDefaultTypeInternal;
extern SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;
class StringRules;
class StringRulesDefaultTypeInternal;
extern StringRulesDefaultTypeInternal _StringRules_default_instance_;
class TimestampRules;
class TimestampRulesDefaultTypeInternal;
extern TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;
class UInt32Rules;
class UInt32RulesDefaultTypeInternal;
extern UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;
class UInt64Rules;
class UInt64RulesDefaultTypeInternal;
extern UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;
}  // namespace validate

namespace validate {

namespace protobuf_validate_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_validate_2eproto

// ===================================================================

class FieldRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.FieldRules) */ {
 public:
  FieldRules();
  virtual ~FieldRules();

  FieldRules(const FieldRules& from);

  inline FieldRules& operator=(const FieldRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FieldRules(FieldRules&& from) noexcept
    : FieldRules() {
    *this = ::std::move(from);
  }

  inline FieldRules& operator=(FieldRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldRules& default_instance();

  enum TypeCase {
    kFloat = 1,
    kDouble = 2,
    kInt32 = 3,
    kInt64 = 4,
    kUint32 = 5,
    kUint64 = 6,
    kSint32 = 7,
    kSint64 = 8,
    kFixed32 = 9,
    kFixed64 = 10,
    kSfixed32 = 11,
    kSfixed64 = 12,
    kBool = 13,
    kString = 14,
    kBytes = 15,
    kEnum = 16,
    kMessage = 17,
    kRepeated = 18,
    kMap = 19,
    kAny = 20,
    kDuration = 21,
    kTimestamp = 22,
    TYPE_NOT_SET = 0,
  };

  static inline const FieldRules* internal_default_instance() {
    return reinterpret_cast<const FieldRules*>(
               &_FieldRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(FieldRules* other);
  friend void swap(FieldRules& a, FieldRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FieldRules* New() const PROTOBUF_FINAL { return New(NULL); }

  FieldRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FieldRules& from);
  void MergeFrom(const FieldRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FieldRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .validate.FloatRules float = 1;
  bool has_float_() const;
  void clear_float_();
  static const int kFloatFieldNumber = 1;
  const ::validate::FloatRules& float_() const;
  ::validate::FloatRules* mutable_float_();
  ::validate::FloatRules* release_float_();
  void set_allocated_float_(::validate::FloatRules* float_);

  // optional .validate.DoubleRules double = 2;
  bool has_double_() const;
  void clear_double_();
  static const int kDoubleFieldNumber = 2;
  const ::validate::DoubleRules& double_() const;
  ::validate::DoubleRules* mutable_double_();
  ::validate::DoubleRules* release_double_();
  void set_allocated_double_(::validate::DoubleRules* double_);

  // optional .validate.Int32Rules int32 = 3;
  bool has_int32() const;
  void clear_int32();
  static const int kInt32FieldNumber = 3;
  const ::validate::Int32Rules& int32() const;
  ::validate::Int32Rules* mutable_int32();
  ::validate::Int32Rules* release_int32();
  void set_allocated_int32(::validate::Int32Rules* int32);

  // optional .validate.Int64Rules int64 = 4;
  bool has_int64() const;
  void clear_int64();
  static const int kInt64FieldNumber = 4;
  const ::validate::Int64Rules& int64() const;
  ::validate::Int64Rules* mutable_int64();
  ::validate::Int64Rules* release_int64();
  void set_allocated_int64(::validate::Int64Rules* int64);

  // optional .validate.UInt32Rules uint32 = 5;
  bool has_uint32() const;
  void clear_uint32();
  static const int kUint32FieldNumber = 5;
  const ::validate::UInt32Rules& uint32() const;
  ::validate::UInt32Rules* mutable_uint32();
  ::validate::UInt32Rules* release_uint32();
  void set_allocated_uint32(::validate::UInt32Rules* uint32);

  // optional .validate.UInt64Rules uint64 = 6;
  bool has_uint64() const;
  void clear_uint64();
  static const int kUint64FieldNumber = 6;
  const ::validate::UInt64Rules& uint64() const;
  ::validate::UInt64Rules* mutable_uint64();
  ::validate::UInt64Rules* release_uint64();
  void set_allocated_uint64(::validate::UInt64Rules* uint64);

  // optional .validate.SInt32Rules sint32 = 7;
  bool has_sint32() const;
  void clear_sint32();
  static const int kSint32FieldNumber = 7;
  const ::validate::SInt32Rules& sint32() const;
  ::validate::SInt32Rules* mutable_sint32();
  ::validate::SInt32Rules* release_sint32();
  void set_allocated_sint32(::validate::SInt32Rules* sint32);

  // optional .validate.SInt64Rules sint64 = 8;
  bool has_sint64() const;
  void clear_sint64();
  static const int kSint64FieldNumber = 8;
  const ::validate::SInt64Rules& sint64() const;
  ::validate::SInt64Rules* mutable_sint64();
  ::validate::SInt64Rules* release_sint64();
  void set_allocated_sint64(::validate::SInt64Rules* sint64);

  // optional .validate.Fixed32Rules fixed32 = 9;
  bool has_fixed32() const;
  void clear_fixed32();
  static const int kFixed32FieldNumber = 9;
  const ::validate::Fixed32Rules& fixed32() const;
  ::validate::Fixed32Rules* mutable_fixed32();
  ::validate::Fixed32Rules* release_fixed32();
  void set_allocated_fixed32(::validate::Fixed32Rules* fixed32);

  // optional .validate.Fixed64Rules fixed64 = 10;
  bool has_fixed64() const;
  void clear_fixed64();
  static const int kFixed64FieldNumber = 10;
  const ::validate::Fixed64Rules& fixed64() const;
  ::validate::Fixed64Rules* mutable_fixed64();
  ::validate::Fixed64Rules* release_fixed64();
  void set_allocated_fixed64(::validate::Fixed64Rules* fixed64);

  // optional .validate.SFixed32Rules sfixed32 = 11;
  bool has_sfixed32() const;
  void clear_sfixed32();
  static const int kSfixed32FieldNumber = 11;
  const ::validate::SFixed32Rules& sfixed32() const;
  ::validate::SFixed32Rules* mutable_sfixed32();
  ::validate::SFixed32Rules* release_sfixed32();
  void set_allocated_sfixed32(::validate::SFixed32Rules* sfixed32);

  // optional .validate.SFixed64Rules sfixed64 = 12;
  bool has_sfixed64() const;
  void clear_sfixed64();
  static const int kSfixed64FieldNumber = 12;
  const ::validate::SFixed64Rules& sfixed64() const;
  ::validate::SFixed64Rules* mutable_sfixed64();
  ::validate::SFixed64Rules* release_sfixed64();
  void set_allocated_sfixed64(::validate::SFixed64Rules* sfixed64);

  // optional .validate.BoolRules bool = 13;
  bool has_bool_() const;
  void clear_bool_();
  static const int kBoolFieldNumber = 13;
  const ::validate::BoolRules& bool_() const;
  ::validate::BoolRules* mutable_bool_();
  ::validate::BoolRules* release_bool_();
  void set_allocated_bool_(::validate::BoolRules* bool_);

  // optional .validate.StringRules string = 14;
  bool has_string() const;
  void clear_string();
  static const int kStringFieldNumber = 14;
  const ::validate::StringRules& string() const;
  ::validate::StringRules* mutable_string();
  ::validate::StringRules* release_string();
  void set_allocated_string(::validate::StringRules* string);

  // optional .validate.BytesRules bytes = 15;
  bool has_bytes() const;
  void clear_bytes();
  static const int kBytesFieldNumber = 15;
  const ::validate::BytesRules& bytes() const;
  ::validate::BytesRules* mutable_bytes();
  ::validate::BytesRules* release_bytes();
  void set_allocated_bytes(::validate::BytesRules* bytes);

  // optional .validate.EnumRules enum = 16;
  bool has_enum_() const;
  void clear_enum_();
  static const int kEnumFieldNumber = 16;
  const ::validate::EnumRules& enum_() const;
  ::validate::EnumRules* mutable_enum_();
  ::validate::EnumRules* release_enum_();
  void set_allocated_enum_(::validate::EnumRules* enum_);

  // optional .validate.MessageRules message = 17;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 17;
  const ::validate::MessageRules& message() const;
  ::validate::MessageRules* mutable_message();
  ::validate::MessageRules* release_message();
  void set_allocated_message(::validate::MessageRules* message);

  // optional .validate.RepeatedRules repeated = 18;
  bool has_repeated() const;
  void clear_repeated();
  static const int kRepeatedFieldNumber = 18;
  const ::validate::RepeatedRules& repeated() const;
  ::validate::RepeatedRules* mutable_repeated();
  ::validate::RepeatedRules* release_repeated();
  void set_allocated_repeated(::validate::RepeatedRules* repeated);

  // optional .validate.MapRules map = 19;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 19;
  const ::validate::MapRules& map() const;
  ::validate::MapRules* mutable_map();
  ::validate::MapRules* release_map();
  void set_allocated_map(::validate::MapRules* map);

  // optional .validate.AnyRules any = 20;
  bool has_any() const;
  void clear_any();
  static const int kAnyFieldNumber = 20;
  const ::validate::AnyRules& any() const;
  ::validate::AnyRules* mutable_any();
  ::validate::AnyRules* release_any();
  void set_allocated_any(::validate::AnyRules* any);

  // optional .validate.DurationRules duration = 21;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 21;
  const ::validate::DurationRules& duration() const;
  ::validate::DurationRules* mutable_duration();
  ::validate::DurationRules* release_duration();
  void set_allocated_duration(::validate::DurationRules* duration);

  // optional .validate.TimestampRules timestamp = 22;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 22;
  const ::validate::TimestampRules& timestamp() const;
  ::validate::TimestampRules* mutable_timestamp();
  ::validate::TimestampRules* release_timestamp();
  void set_allocated_timestamp(::validate::TimestampRules* timestamp);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:validate.FieldRules)
 private:
  void set_has_float_();
  void set_has_double_();
  void set_has_int32();
  void set_has_int64();
  void set_has_uint32();
  void set_has_uint64();
  void set_has_sint32();
  void set_has_sint64();
  void set_has_fixed32();
  void set_has_fixed64();
  void set_has_sfixed32();
  void set_has_sfixed64();
  void set_has_bool_();
  void set_has_string();
  void set_has_bytes();
  void set_has_enum_();
  void set_has_message();
  void set_has_repeated();
  void set_has_map();
  void set_has_any();
  void set_has_duration();
  void set_has_timestamp();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union TypeUnion {
    TypeUnion() {}
    ::validate::FloatRules* float__;
    ::validate::DoubleRules* double__;
    ::validate::Int32Rules* int32_;
    ::validate::Int64Rules* int64_;
    ::validate::UInt32Rules* uint32_;
    ::validate::UInt64Rules* uint64_;
    ::validate::SInt32Rules* sint32_;
    ::validate::SInt64Rules* sint64_;
    ::validate::Fixed32Rules* fixed32_;
    ::validate::Fixed64Rules* fixed64_;
    ::validate::SFixed32Rules* sfixed32_;
    ::validate::SFixed64Rules* sfixed64_;
    ::validate::BoolRules* bool__;
    ::validate::StringRules* string_;
    ::validate::BytesRules* bytes_;
    ::validate::EnumRules* enum__;
    ::validate::MessageRules* message_;
    ::validate::RepeatedRules* repeated_;
    ::validate::MapRules* map_;
    ::validate::AnyRules* any_;
    ::validate::DurationRules* duration_;
    ::validate::TimestampRules* timestamp_;
  } type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FloatRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.FloatRules) */ {
 public:
  FloatRules();
  virtual ~FloatRules();

  FloatRules(const FloatRules& from);

  inline FloatRules& operator=(const FloatRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatRules(FloatRules&& from) noexcept
    : FloatRules() {
    *this = ::std::move(from);
  }

  inline FloatRules& operator=(FloatRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatRules& default_instance();

  static inline const FloatRules* internal_default_instance() {
    return reinterpret_cast<const FloatRules*>(
               &_FloatRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(FloatRules* other);
  friend void swap(FloatRules& a, FloatRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatRules* New() const PROTOBUF_FINAL { return New(NULL); }

  FloatRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FloatRules& from);
  void MergeFrom(const FloatRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FloatRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  float in(int index) const;
  void set_in(int index, float value);
  void add_in(float value);
  const ::google::protobuf::RepeatedField< float >&
      in() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_in();

  // repeated float not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  float not_in(int index) const;
  void set_not_in(int index, float value);
  void add_not_in(float value);
  const ::google::protobuf::RepeatedField< float >&
      not_in() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_not_in();

  // optional float const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  float const_() const;
  void set_const_(float value);

  // optional float lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  float lt() const;
  void set_lt(float value);

  // optional float lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  float lte() const;
  void set_lte(float value);

  // optional float gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  float gt() const;
  void set_gt(float value);

  // optional float gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  float gte() const;
  void set_gte(float value);

  // @@protoc_insertion_point(class_scope:validate.FloatRules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > in_;
  ::google::protobuf::RepeatedField< float > not_in_;
  float const__;
  float lt_;
  float lte_;
  float gt_;
  float gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoubleRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.DoubleRules) */ {
 public:
  DoubleRules();
  virtual ~DoubleRules();

  DoubleRules(const DoubleRules& from);

  inline DoubleRules& operator=(const DoubleRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleRules(DoubleRules&& from) noexcept
    : DoubleRules() {
    *this = ::std::move(from);
  }

  inline DoubleRules& operator=(DoubleRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleRules& default_instance();

  static inline const DoubleRules* internal_default_instance() {
    return reinterpret_cast<const DoubleRules*>(
               &_DoubleRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DoubleRules* other);
  friend void swap(DoubleRules& a, DoubleRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleRules* New() const PROTOBUF_FINAL { return New(NULL); }

  DoubleRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DoubleRules& from);
  void MergeFrom(const DoubleRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DoubleRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  double in(int index) const;
  void set_in(int index, double value);
  void add_in(double value);
  const ::google::protobuf::RepeatedField< double >&
      in() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_in();

  // repeated double not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  double not_in(int index) const;
  void set_not_in(int index, double value);
  void add_not_in(double value);
  const ::google::protobuf::RepeatedField< double >&
      not_in() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_not_in();

  // optional double const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  double const_() const;
  void set_const_(double value);

  // optional double lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  double lt() const;
  void set_lt(double value);

  // optional double lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  double lte() const;
  void set_lte(double value);

  // optional double gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  double gt() const;
  void set_gt(double value);

  // optional double gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  double gte() const;
  void set_gte(double value);

  // @@protoc_insertion_point(class_scope:validate.DoubleRules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > in_;
  ::google::protobuf::RepeatedField< double > not_in_;
  double const__;
  double lt_;
  double lte_;
  double gt_;
  double gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int32Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.Int32Rules) */ {
 public:
  Int32Rules();
  virtual ~Int32Rules();

  Int32Rules(const Int32Rules& from);

  inline Int32Rules& operator=(const Int32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int32Rules(Int32Rules&& from) noexcept
    : Int32Rules() {
    *this = ::std::move(from);
  }

  inline Int32Rules& operator=(Int32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Int32Rules& default_instance();

  static inline const Int32Rules* internal_default_instance() {
    return reinterpret_cast<const Int32Rules*>(
               &_Int32Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Int32Rules* other);
  friend void swap(Int32Rules& a, Int32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int32Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  Int32Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Int32Rules& from);
  void MergeFrom(const Int32Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Int32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated int32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // optional int32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int32 const_() const;
  void set_const_(::google::protobuf::int32 value);

  // optional int32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int32 lt() const;
  void set_lt(::google::protobuf::int32 value);

  // optional int32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int32 lte() const;
  void set_lte(::google::protobuf::int32 value);

  // optional int32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int32 gt() const;
  void set_gt(::google::protobuf::int32 value);

  // optional int32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int32 gte() const;
  void set_gte(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:validate.Int32Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  ::google::protobuf::int32 const__;
  ::google::protobuf::int32 lt_;
  ::google::protobuf::int32 lte_;
  ::google::protobuf::int32 gt_;
  ::google::protobuf::int32 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int64Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.Int64Rules) */ {
 public:
  Int64Rules();
  virtual ~Int64Rules();

  Int64Rules(const Int64Rules& from);

  inline Int64Rules& operator=(const Int64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int64Rules(Int64Rules&& from) noexcept
    : Int64Rules() {
    *this = ::std::move(from);
  }

  inline Int64Rules& operator=(Int64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Int64Rules& default_instance();

  static inline const Int64Rules* internal_default_instance() {
    return reinterpret_cast<const Int64Rules*>(
               &_Int64Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Int64Rules* other);
  friend void swap(Int64Rules& a, Int64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int64Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  Int64Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Int64Rules& from);
  void MergeFrom(const Int64Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Int64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int64 in(int index) const;
  void set_in(int index, ::google::protobuf::int64 value);
  void add_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_in();

  // repeated int64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int64 value);
  void add_not_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_not_in();

  // optional int64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int64 const_() const;
  void set_const_(::google::protobuf::int64 value);

  // optional int64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int64 lt() const;
  void set_lt(::google::protobuf::int64 value);

  // optional int64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int64 lte() const;
  void set_lte(::google::protobuf::int64 value);

  // optional int64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int64 gt() const;
  void set_gt(::google::protobuf::int64 value);

  // optional int64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int64 gte() const;
  void set_gte(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:validate.Int64Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > not_in_;
  ::google::protobuf::int64 const__;
  ::google::protobuf::int64 lt_;
  ::google::protobuf::int64 lte_;
  ::google::protobuf::int64 gt_;
  ::google::protobuf::int64 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UInt32Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.UInt32Rules) */ {
 public:
  UInt32Rules();
  virtual ~UInt32Rules();

  UInt32Rules(const UInt32Rules& from);

  inline UInt32Rules& operator=(const UInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt32Rules(UInt32Rules&& from) noexcept
    : UInt32Rules() {
    *this = ::std::move(from);
  }

  inline UInt32Rules& operator=(UInt32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UInt32Rules& default_instance();

  static inline const UInt32Rules* internal_default_instance() {
    return reinterpret_cast<const UInt32Rules*>(
               &_UInt32Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(UInt32Rules* other);
  friend void swap(UInt32Rules& a, UInt32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt32Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  UInt32Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UInt32Rules& from);
  void MergeFrom(const UInt32Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UInt32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::uint32 in(int index) const;
  void set_in(int index, ::google::protobuf::uint32 value);
  void add_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_in();

  // repeated uint32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::uint32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint32 value);
  void add_not_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_not_in();

  // optional uint32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::uint32 const_() const;
  void set_const_(::google::protobuf::uint32 value);

  // optional uint32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::uint32 lt() const;
  void set_lt(::google::protobuf::uint32 value);

  // optional uint32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::uint32 lte() const;
  void set_lte(::google::protobuf::uint32 value);

  // optional uint32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::uint32 gt() const;
  void set_gt(::google::protobuf::uint32 value);

  // optional uint32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::uint32 gte() const;
  void set_gte(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:validate.UInt32Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > not_in_;
  ::google::protobuf::uint32 const__;
  ::google::protobuf::uint32 lt_;
  ::google::protobuf::uint32 lte_;
  ::google::protobuf::uint32 gt_;
  ::google::protobuf::uint32 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UInt64Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.UInt64Rules) */ {
 public:
  UInt64Rules();
  virtual ~UInt64Rules();

  UInt64Rules(const UInt64Rules& from);

  inline UInt64Rules& operator=(const UInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt64Rules(UInt64Rules&& from) noexcept
    : UInt64Rules() {
    *this = ::std::move(from);
  }

  inline UInt64Rules& operator=(UInt64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UInt64Rules& default_instance();

  static inline const UInt64Rules* internal_default_instance() {
    return reinterpret_cast<const UInt64Rules*>(
               &_UInt64Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(UInt64Rules* other);
  friend void swap(UInt64Rules& a, UInt64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt64Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  UInt64Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UInt64Rules& from);
  void MergeFrom(const UInt64Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UInt64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::uint64 in(int index) const;
  void set_in(int index, ::google::protobuf::uint64 value);
  void add_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_in();

  // repeated uint64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::uint64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint64 value);
  void add_not_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_not_in();

  // optional uint64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::uint64 const_() const;
  void set_const_(::google::protobuf::uint64 value);

  // optional uint64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::uint64 lt() const;
  void set_lt(::google::protobuf::uint64 value);

  // optional uint64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::uint64 lte() const;
  void set_lte(::google::protobuf::uint64 value);

  // optional uint64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::uint64 gt() const;
  void set_gt(::google::protobuf::uint64 value);

  // optional uint64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::uint64 gte() const;
  void set_gte(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:validate.UInt64Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > not_in_;
  ::google::protobuf::uint64 const__;
  ::google::protobuf::uint64 lt_;
  ::google::protobuf::uint64 lte_;
  ::google::protobuf::uint64 gt_;
  ::google::protobuf::uint64 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SInt32Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.SInt32Rules) */ {
 public:
  SInt32Rules();
  virtual ~SInt32Rules();

  SInt32Rules(const SInt32Rules& from);

  inline SInt32Rules& operator=(const SInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SInt32Rules(SInt32Rules&& from) noexcept
    : SInt32Rules() {
    *this = ::std::move(from);
  }

  inline SInt32Rules& operator=(SInt32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SInt32Rules& default_instance();

  static inline const SInt32Rules* internal_default_instance() {
    return reinterpret_cast<const SInt32Rules*>(
               &_SInt32Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SInt32Rules* other);
  friend void swap(SInt32Rules& a, SInt32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SInt32Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  SInt32Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SInt32Rules& from);
  void MergeFrom(const SInt32Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SInt32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated sint32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // optional sint32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int32 const_() const;
  void set_const_(::google::protobuf::int32 value);

  // optional sint32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int32 lt() const;
  void set_lt(::google::protobuf::int32 value);

  // optional sint32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int32 lte() const;
  void set_lte(::google::protobuf::int32 value);

  // optional sint32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int32 gt() const;
  void set_gt(::google::protobuf::int32 value);

  // optional sint32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int32 gte() const;
  void set_gte(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:validate.SInt32Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  ::google::protobuf::int32 const__;
  ::google::protobuf::int32 lt_;
  ::google::protobuf::int32 lte_;
  ::google::protobuf::int32 gt_;
  ::google::protobuf::int32 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SInt64Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.SInt64Rules) */ {
 public:
  SInt64Rules();
  virtual ~SInt64Rules();

  SInt64Rules(const SInt64Rules& from);

  inline SInt64Rules& operator=(const SInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SInt64Rules(SInt64Rules&& from) noexcept
    : SInt64Rules() {
    *this = ::std::move(from);
  }

  inline SInt64Rules& operator=(SInt64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SInt64Rules& default_instance();

  static inline const SInt64Rules* internal_default_instance() {
    return reinterpret_cast<const SInt64Rules*>(
               &_SInt64Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SInt64Rules* other);
  friend void swap(SInt64Rules& a, SInt64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SInt64Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  SInt64Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SInt64Rules& from);
  void MergeFrom(const SInt64Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SInt64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int64 in(int index) const;
  void set_in(int index, ::google::protobuf::int64 value);
  void add_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_in();

  // repeated sint64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int64 value);
  void add_not_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_not_in();

  // optional sint64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int64 const_() const;
  void set_const_(::google::protobuf::int64 value);

  // optional sint64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int64 lt() const;
  void set_lt(::google::protobuf::int64 value);

  // optional sint64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int64 lte() const;
  void set_lte(::google::protobuf::int64 value);

  // optional sint64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int64 gt() const;
  void set_gt(::google::protobuf::int64 value);

  // optional sint64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int64 gte() const;
  void set_gte(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:validate.SInt64Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > not_in_;
  ::google::protobuf::int64 const__;
  ::google::protobuf::int64 lt_;
  ::google::protobuf::int64 lte_;
  ::google::protobuf::int64 gt_;
  ::google::protobuf::int64 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Fixed32Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.Fixed32Rules) */ {
 public:
  Fixed32Rules();
  virtual ~Fixed32Rules();

  Fixed32Rules(const Fixed32Rules& from);

  inline Fixed32Rules& operator=(const Fixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fixed32Rules(Fixed32Rules&& from) noexcept
    : Fixed32Rules() {
    *this = ::std::move(from);
  }

  inline Fixed32Rules& operator=(Fixed32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fixed32Rules& default_instance();

  static inline const Fixed32Rules* internal_default_instance() {
    return reinterpret_cast<const Fixed32Rules*>(
               &_Fixed32Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Fixed32Rules* other);
  friend void swap(Fixed32Rules& a, Fixed32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fixed32Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  Fixed32Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Fixed32Rules& from);
  void MergeFrom(const Fixed32Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Fixed32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::uint32 in(int index) const;
  void set_in(int index, ::google::protobuf::uint32 value);
  void add_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_in();

  // repeated fixed32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::uint32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint32 value);
  void add_not_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_not_in();

  // optional fixed32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::uint32 const_() const;
  void set_const_(::google::protobuf::uint32 value);

  // optional fixed32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::uint32 lt() const;
  void set_lt(::google::protobuf::uint32 value);

  // optional fixed32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::uint32 lte() const;
  void set_lte(::google::protobuf::uint32 value);

  // optional fixed32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::uint32 gt() const;
  void set_gt(::google::protobuf::uint32 value);

  // optional fixed32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::uint32 gte() const;
  void set_gte(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:validate.Fixed32Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > not_in_;
  ::google::protobuf::uint32 const__;
  ::google::protobuf::uint32 lt_;
  ::google::protobuf::uint32 lte_;
  ::google::protobuf::uint32 gt_;
  ::google::protobuf::uint32 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Fixed64Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.Fixed64Rules) */ {
 public:
  Fixed64Rules();
  virtual ~Fixed64Rules();

  Fixed64Rules(const Fixed64Rules& from);

  inline Fixed64Rules& operator=(const Fixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fixed64Rules(Fixed64Rules&& from) noexcept
    : Fixed64Rules() {
    *this = ::std::move(from);
  }

  inline Fixed64Rules& operator=(Fixed64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fixed64Rules& default_instance();

  static inline const Fixed64Rules* internal_default_instance() {
    return reinterpret_cast<const Fixed64Rules*>(
               &_Fixed64Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Fixed64Rules* other);
  friend void swap(Fixed64Rules& a, Fixed64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fixed64Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  Fixed64Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Fixed64Rules& from);
  void MergeFrom(const Fixed64Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Fixed64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::uint64 in(int index) const;
  void set_in(int index, ::google::protobuf::uint64 value);
  void add_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_in();

  // repeated fixed64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::uint64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint64 value);
  void add_not_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_not_in();

  // optional fixed64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::uint64 const_() const;
  void set_const_(::google::protobuf::uint64 value);

  // optional fixed64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::uint64 lt() const;
  void set_lt(::google::protobuf::uint64 value);

  // optional fixed64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::uint64 lte() const;
  void set_lte(::google::protobuf::uint64 value);

  // optional fixed64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::uint64 gt() const;
  void set_gt(::google::protobuf::uint64 value);

  // optional fixed64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::uint64 gte() const;
  void set_gte(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:validate.Fixed64Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > not_in_;
  ::google::protobuf::uint64 const__;
  ::google::protobuf::uint64 lt_;
  ::google::protobuf::uint64 lte_;
  ::google::protobuf::uint64 gt_;
  ::google::protobuf::uint64 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SFixed32Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.SFixed32Rules) */ {
 public:
  SFixed32Rules();
  virtual ~SFixed32Rules();

  SFixed32Rules(const SFixed32Rules& from);

  inline SFixed32Rules& operator=(const SFixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SFixed32Rules(SFixed32Rules&& from) noexcept
    : SFixed32Rules() {
    *this = ::std::move(from);
  }

  inline SFixed32Rules& operator=(SFixed32Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SFixed32Rules& default_instance();

  static inline const SFixed32Rules* internal_default_instance() {
    return reinterpret_cast<const SFixed32Rules*>(
               &_SFixed32Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SFixed32Rules* other);
  friend void swap(SFixed32Rules& a, SFixed32Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SFixed32Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  SFixed32Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SFixed32Rules& from);
  void MergeFrom(const SFixed32Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SFixed32Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sfixed32 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated sfixed32 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // optional sfixed32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int32 const_() const;
  void set_const_(::google::protobuf::int32 value);

  // optional sfixed32 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int32 lt() const;
  void set_lt(::google::protobuf::int32 value);

  // optional sfixed32 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int32 lte() const;
  void set_lte(::google::protobuf::int32 value);

  // optional sfixed32 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int32 gt() const;
  void set_gt(::google::protobuf::int32 value);

  // optional sfixed32 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int32 gte() const;
  void set_gte(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:validate.SFixed32Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  ::google::protobuf::int32 const__;
  ::google::protobuf::int32 lt_;
  ::google::protobuf::int32 lte_;
  ::google::protobuf::int32 gt_;
  ::google::protobuf::int32 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SFixed64Rules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.SFixed64Rules) */ {
 public:
  SFixed64Rules();
  virtual ~SFixed64Rules();

  SFixed64Rules(const SFixed64Rules& from);

  inline SFixed64Rules& operator=(const SFixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SFixed64Rules(SFixed64Rules&& from) noexcept
    : SFixed64Rules() {
    *this = ::std::move(from);
  }

  inline SFixed64Rules& operator=(SFixed64Rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SFixed64Rules& default_instance();

  static inline const SFixed64Rules* internal_default_instance() {
    return reinterpret_cast<const SFixed64Rules*>(
               &_SFixed64Rules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(SFixed64Rules* other);
  friend void swap(SFixed64Rules& a, SFixed64Rules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SFixed64Rules* New() const PROTOBUF_FINAL { return New(NULL); }

  SFixed64Rules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SFixed64Rules& from);
  void MergeFrom(const SFixed64Rules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SFixed64Rules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sfixed64 in = 6;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 6;
  ::google::protobuf::int64 in(int index) const;
  void set_in(int index, ::google::protobuf::int64 value);
  void add_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_in();

  // repeated sfixed64 not_in = 7;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 7;
  ::google::protobuf::int64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int64 value);
  void add_not_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_not_in();

  // optional sfixed64 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int64 const_() const;
  void set_const_(::google::protobuf::int64 value);

  // optional sfixed64 lt = 2;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 2;
  ::google::protobuf::int64 lt() const;
  void set_lt(::google::protobuf::int64 value);

  // optional sfixed64 lte = 3;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 3;
  ::google::protobuf::int64 lte() const;
  void set_lte(::google::protobuf::int64 value);

  // optional sfixed64 gt = 4;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 4;
  ::google::protobuf::int64 gt() const;
  void set_gt(::google::protobuf::int64 value);

  // optional sfixed64 gte = 5;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 5;
  ::google::protobuf::int64 gte() const;
  void set_gte(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:validate.SFixed64Rules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > not_in_;
  ::google::protobuf::int64 const__;
  ::google::protobuf::int64 lt_;
  ::google::protobuf::int64 lte_;
  ::google::protobuf::int64 gt_;
  ::google::protobuf::int64 gte_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoolRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.BoolRules) */ {
 public:
  BoolRules();
  virtual ~BoolRules();

  BoolRules(const BoolRules& from);

  inline BoolRules& operator=(const BoolRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoolRules(BoolRules&& from) noexcept
    : BoolRules() {
    *this = ::std::move(from);
  }

  inline BoolRules& operator=(BoolRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolRules& default_instance();

  static inline const BoolRules* internal_default_instance() {
    return reinterpret_cast<const BoolRules*>(
               &_BoolRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(BoolRules* other);
  friend void swap(BoolRules& a, BoolRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoolRules* New() const PROTOBUF_FINAL { return New(NULL); }

  BoolRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoolRules& from);
  void MergeFrom(const BoolRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoolRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  bool const_() const;
  void set_const_(bool value);

  // @@protoc_insertion_point(class_scope:validate.BoolRules)
 private:
  void set_has_const_();
  void clear_has_const_();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool const__;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.StringRules) */ {
 public:
  StringRules();
  virtual ~StringRules();

  StringRules(const StringRules& from);

  inline StringRules& operator=(const StringRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringRules(StringRules&& from) noexcept
    : StringRules() {
    *this = ::std::move(from);
  }

  inline StringRules& operator=(StringRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringRules& default_instance();

  enum WellKnownCase {
    kEmail = 12,
    kHostname = 13,
    kIp = 14,
    kIpv4 = 15,
    kIpv6 = 16,
    kUri = 17,
    kUriRef = 18,
    WELL_KNOWN_NOT_SET = 0,
  };

  static inline const StringRules* internal_default_instance() {
    return reinterpret_cast<const StringRules*>(
               &_StringRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(StringRules* other);
  friend void swap(StringRules& a, StringRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringRules* New() const PROTOBUF_FINAL { return New(NULL); }

  StringRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StringRules& from);
  void MergeFrom(const StringRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StringRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string in = 10;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 10;
  const ::std::string& in(int index) const;
  ::std::string* mutable_in(int index);
  void set_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_in(int index, ::std::string&& value);
  #endif
  void set_in(int index, const char* value);
  void set_in(int index, const char* value, size_t size);
  ::std::string* add_in();
  void add_in(const ::std::string& value);
  #if LANG_CXX11
  void add_in(::std::string&& value);
  #endif
  void add_in(const char* value);
  void add_in(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_in();

  // repeated string not_in = 11;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 11;
  const ::std::string& not_in(int index) const;
  ::std::string* mutable_not_in(int index);
  void set_not_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_not_in(int index, ::std::string&& value);
  #endif
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const char* value, size_t size);
  ::std::string* add_not_in();
  void add_not_in(const ::std::string& value);
  #if LANG_CXX11
  void add_not_in(::std::string&& value);
  #endif
  void add_not_in(const char* value);
  void add_not_in(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_not_in();

  // optional string const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  const ::std::string& const_() const;
  void set_const_(const ::std::string& value);
  #if LANG_CXX11
  void set_const_(::std::string&& value);
  #endif
  void set_const_(const char* value);
  void set_const_(const char* value, size_t size);
  ::std::string* mutable_const_();
  ::std::string* release_const_();
  void set_allocated_const_(::std::string* const_);

  // optional string pattern = 6;
  bool has_pattern() const;
  void clear_pattern();
  static const int kPatternFieldNumber = 6;
  const ::std::string& pattern() const;
  void set_pattern(const ::std::string& value);
  #if LANG_CXX11
  void set_pattern(::std::string&& value);
  #endif
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  ::std::string* mutable_pattern();
  ::std::string* release_pattern();
  void set_allocated_pattern(::std::string* pattern);

  // optional string prefix = 7;
  bool has_prefix() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 7;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // optional string suffix = 8;
  bool has_suffix() const;
  void clear_suffix();
  static const int kSuffixFieldNumber = 8;
  const ::std::string& suffix() const;
  void set_suffix(const ::std::string& value);
  #if LANG_CXX11
  void set_suffix(::std::string&& value);
  #endif
  void set_suffix(const char* value);
  void set_suffix(const char* value, size_t size);
  ::std::string* mutable_suffix();
  ::std::string* release_suffix();
  void set_allocated_suffix(::std::string* suffix);

  // optional string contains = 9;
  bool has_contains() const;
  void clear_contains();
  static const int kContainsFieldNumber = 9;
  const ::std::string& contains() const;
  void set_contains(const ::std::string& value);
  #if LANG_CXX11
  void set_contains(::std::string&& value);
  #endif
  void set_contains(const char* value);
  void set_contains(const char* value, size_t size);
  ::std::string* mutable_contains();
  ::std::string* release_contains();
  void set_allocated_contains(::std::string* contains);

  // optional uint64 min_len = 2;
  bool has_min_len() const;
  void clear_min_len();
  static const int kMinLenFieldNumber = 2;
  ::google::protobuf::uint64 min_len() const;
  void set_min_len(::google::protobuf::uint64 value);

  // optional uint64 max_len = 3;
  bool has_max_len() const;
  void clear_max_len();
  static const int kMaxLenFieldNumber = 3;
  ::google::protobuf::uint64 max_len() const;
  void set_max_len(::google::protobuf::uint64 value);

  // optional uint64 min_bytes = 4;
  bool has_min_bytes() const;
  void clear_min_bytes();
  static const int kMinBytesFieldNumber = 4;
  ::google::protobuf::uint64 min_bytes() const;
  void set_min_bytes(::google::protobuf::uint64 value);

  // optional uint64 max_bytes = 5;
  bool has_max_bytes() const;
  void clear_max_bytes();
  static const int kMaxBytesFieldNumber = 5;
  ::google::protobuf::uint64 max_bytes() const;
  void set_max_bytes(::google::protobuf::uint64 value);

  // optional uint64 len = 19;
  bool has_len() const;
  void clear_len();
  static const int kLenFieldNumber = 19;
  ::google::protobuf::uint64 len() const;
  void set_len(::google::protobuf::uint64 value);

  // optional uint64 len_bytes = 20;
  bool has_len_bytes() const;
  void clear_len_bytes();
  static const int kLenBytesFieldNumber = 20;
  ::google::protobuf::uint64 len_bytes() const;
  void set_len_bytes(::google::protobuf::uint64 value);

  // optional bool email = 12;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 12;
  bool email() const;
  void set_email(bool value);

  // optional bool hostname = 13;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 13;
  bool hostname() const;
  void set_hostname(bool value);

  // optional bool ip = 14;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 14;
  bool ip() const;
  void set_ip(bool value);

  // optional bool ipv4 = 15;
  bool has_ipv4() const;
  void clear_ipv4();
  static const int kIpv4FieldNumber = 15;
  bool ipv4() const;
  void set_ipv4(bool value);

  // optional bool ipv6 = 16;
  bool has_ipv6() const;
  void clear_ipv6();
  static const int kIpv6FieldNumber = 16;
  bool ipv6() const;
  void set_ipv6(bool value);

  // optional bool uri = 17;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 17;
  bool uri() const;
  void set_uri(bool value);

  // optional bool uri_ref = 18;
  bool has_uri_ref() const;
  void clear_uri_ref();
  static const int kUriRefFieldNumber = 18;
  bool uri_ref() const;
  void set_uri_ref(bool value);

  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:validate.StringRules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_len();
  void clear_has_len();
  void set_has_min_len();
  void clear_has_min_len();
  void set_has_max_len();
  void clear_has_max_len();
  void set_has_len_bytes();
  void clear_has_len_bytes();
  void set_has_min_bytes();
  void clear_has_min_bytes();
  void set_has_max_bytes();
  void clear_has_max_bytes();
  void set_has_pattern();
  void clear_has_pattern();
  void set_has_prefix();
  void clear_has_prefix();
  void set_has_suffix();
  void clear_has_suffix();
  void set_has_contains();
  void clear_has_contains();
  void set_has_email();
  void set_has_hostname();
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();
  void set_has_uri();
  void set_has_uri_ref();

  inline bool has_well_known() const;
  void clear_well_known();
  inline void clear_has_well_known();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> in_;
  ::google::protobuf::RepeatedPtrField< ::std::string> not_in_;
  ::google::protobuf::internal::ArenaStringPtr const__;
  ::google::protobuf::internal::ArenaStringPtr pattern_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr suffix_;
  ::google::protobuf::internal::ArenaStringPtr contains_;
  ::google::protobuf::uint64 min_len_;
  ::google::protobuf::uint64 max_len_;
  ::google::protobuf::uint64 min_bytes_;
  ::google::protobuf::uint64 max_bytes_;
  ::google::protobuf::uint64 len_;
  ::google::protobuf::uint64 len_bytes_;
  union WellKnownUnion {
    WellKnownUnion() {}
    bool email_;
    bool hostname_;
    bool ip_;
    bool ipv4_;
    bool ipv6_;
    bool uri_;
    bool uri_ref_;
  } well_known_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytesRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.BytesRules) */ {
 public:
  BytesRules();
  virtual ~BytesRules();

  BytesRules(const BytesRules& from);

  inline BytesRules& operator=(const BytesRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytesRules(BytesRules&& from) noexcept
    : BytesRules() {
    *this = ::std::move(from);
  }

  inline BytesRules& operator=(BytesRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytesRules& default_instance();

  enum WellKnownCase {
    kIp = 10,
    kIpv4 = 11,
    kIpv6 = 12,
    WELL_KNOWN_NOT_SET = 0,
  };

  static inline const BytesRules* internal_default_instance() {
    return reinterpret_cast<const BytesRules*>(
               &_BytesRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(BytesRules* other);
  friend void swap(BytesRules& a, BytesRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytesRules* New() const PROTOBUF_FINAL { return New(NULL); }

  BytesRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BytesRules& from);
  void MergeFrom(const BytesRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BytesRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes in = 8;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 8;
  const ::std::string& in(int index) const;
  ::std::string* mutable_in(int index);
  void set_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_in(int index, ::std::string&& value);
  #endif
  void set_in(int index, const char* value);
  void set_in(int index, const void* value, size_t size);
  ::std::string* add_in();
  void add_in(const ::std::string& value);
  #if LANG_CXX11
  void add_in(::std::string&& value);
  #endif
  void add_in(const char* value);
  void add_in(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_in();

  // repeated bytes not_in = 9;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 9;
  const ::std::string& not_in(int index) const;
  ::std::string* mutable_not_in(int index);
  void set_not_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_not_in(int index, ::std::string&& value);
  #endif
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const void* value, size_t size);
  ::std::string* add_not_in();
  void add_not_in(const ::std::string& value);
  #if LANG_CXX11
  void add_not_in(::std::string&& value);
  #endif
  void add_not_in(const char* value);
  void add_not_in(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_not_in();

  // optional bytes const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  const ::std::string& const_() const;
  void set_const_(const ::std::string& value);
  #if LANG_CXX11
  void set_const_(::std::string&& value);
  #endif
  void set_const_(const char* value);
  void set_const_(const void* value, size_t size);
  ::std::string* mutable_const_();
  ::std::string* release_const_();
  void set_allocated_const_(::std::string* const_);

  // optional string pattern = 4;
  bool has_pattern() const;
  void clear_pattern();
  static const int kPatternFieldNumber = 4;
  const ::std::string& pattern() const;
  void set_pattern(const ::std::string& value);
  #if LANG_CXX11
  void set_pattern(::std::string&& value);
  #endif
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  ::std::string* mutable_pattern();
  ::std::string* release_pattern();
  void set_allocated_pattern(::std::string* pattern);

  // optional bytes prefix = 5;
  bool has_prefix() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 5;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const void* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // optional bytes suffix = 6;
  bool has_suffix() const;
  void clear_suffix();
  static const int kSuffixFieldNumber = 6;
  const ::std::string& suffix() const;
  void set_suffix(const ::std::string& value);
  #if LANG_CXX11
  void set_suffix(::std::string&& value);
  #endif
  void set_suffix(const char* value);
  void set_suffix(const void* value, size_t size);
  ::std::string* mutable_suffix();
  ::std::string* release_suffix();
  void set_allocated_suffix(::std::string* suffix);

  // optional bytes contains = 7;
  bool has_contains() const;
  void clear_contains();
  static const int kContainsFieldNumber = 7;
  const ::std::string& contains() const;
  void set_contains(const ::std::string& value);
  #if LANG_CXX11
  void set_contains(::std::string&& value);
  #endif
  void set_contains(const char* value);
  void set_contains(const void* value, size_t size);
  ::std::string* mutable_contains();
  ::std::string* release_contains();
  void set_allocated_contains(::std::string* contains);

  // optional uint64 min_len = 2;
  bool has_min_len() const;
  void clear_min_len();
  static const int kMinLenFieldNumber = 2;
  ::google::protobuf::uint64 min_len() const;
  void set_min_len(::google::protobuf::uint64 value);

  // optional uint64 max_len = 3;
  bool has_max_len() const;
  void clear_max_len();
  static const int kMaxLenFieldNumber = 3;
  ::google::protobuf::uint64 max_len() const;
  void set_max_len(::google::protobuf::uint64 value);

  // optional uint64 len = 13;
  bool has_len() const;
  void clear_len();
  static const int kLenFieldNumber = 13;
  ::google::protobuf::uint64 len() const;
  void set_len(::google::protobuf::uint64 value);

  // optional bool ip = 10;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 10;
  bool ip() const;
  void set_ip(bool value);

  // optional bool ipv4 = 11;
  bool has_ipv4() const;
  void clear_ipv4();
  static const int kIpv4FieldNumber = 11;
  bool ipv4() const;
  void set_ipv4(bool value);

  // optional bool ipv6 = 12;
  bool has_ipv6() const;
  void clear_ipv6();
  static const int kIpv6FieldNumber = 12;
  bool ipv6() const;
  void set_ipv6(bool value);

  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:validate.BytesRules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_len();
  void clear_has_len();
  void set_has_min_len();
  void clear_has_min_len();
  void set_has_max_len();
  void clear_has_max_len();
  void set_has_pattern();
  void clear_has_pattern();
  void set_has_prefix();
  void clear_has_prefix();
  void set_has_suffix();
  void clear_has_suffix();
  void set_has_contains();
  void clear_has_contains();
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();

  inline bool has_well_known() const;
  void clear_well_known();
  inline void clear_has_well_known();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> in_;
  ::google::protobuf::RepeatedPtrField< ::std::string> not_in_;
  ::google::protobuf::internal::ArenaStringPtr const__;
  ::google::protobuf::internal::ArenaStringPtr pattern_;
  ::google::protobuf::internal::ArenaStringPtr prefix_;
  ::google::protobuf::internal::ArenaStringPtr suffix_;
  ::google::protobuf::internal::ArenaStringPtr contains_;
  ::google::protobuf::uint64 min_len_;
  ::google::protobuf::uint64 max_len_;
  ::google::protobuf::uint64 len_;
  union WellKnownUnion {
    WellKnownUnion() {}
    bool ip_;
    bool ipv4_;
    bool ipv6_;
  } well_known_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnumRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.EnumRules) */ {
 public:
  EnumRules();
  virtual ~EnumRules();

  EnumRules(const EnumRules& from);

  inline EnumRules& operator=(const EnumRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnumRules(EnumRules&& from) noexcept
    : EnumRules() {
    *this = ::std::move(from);
  }

  inline EnumRules& operator=(EnumRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnumRules& default_instance();

  static inline const EnumRules* internal_default_instance() {
    return reinterpret_cast<const EnumRules*>(
               &_EnumRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(EnumRules* other);
  friend void swap(EnumRules& a, EnumRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnumRules* New() const PROTOBUF_FINAL { return New(NULL); }

  EnumRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnumRules& from);
  void MergeFrom(const EnumRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnumRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 in = 3;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 3;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated int32 not_in = 4;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 4;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // optional int32 const = 1;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 1;
  ::google::protobuf::int32 const_() const;
  void set_const_(::google::protobuf::int32 value);

  // optional bool defined_only = 2;
  bool has_defined_only() const;
  void clear_defined_only();
  static const int kDefinedOnlyFieldNumber = 2;
  bool defined_only() const;
  void set_defined_only(bool value);

  // @@protoc_insertion_point(class_scope:validate.EnumRules)
 private:
  void set_has_const_();
  void clear_has_const_();
  void set_has_defined_only();
  void clear_has_defined_only();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  ::google::protobuf::int32 const__;
  bool defined_only_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.MessageRules) */ {
 public:
  MessageRules();
  virtual ~MessageRules();

  MessageRules(const MessageRules& from);

  inline MessageRules& operator=(const MessageRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageRules(MessageRules&& from) noexcept
    : MessageRules() {
    *this = ::std::move(from);
  }

  inline MessageRules& operator=(MessageRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageRules& default_instance();

  static inline const MessageRules* internal_default_instance() {
    return reinterpret_cast<const MessageRules*>(
               &_MessageRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(MessageRules* other);
  friend void swap(MessageRules& a, MessageRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageRules* New() const PROTOBUF_FINAL { return New(NULL); }

  MessageRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MessageRules& from);
  void MergeFrom(const MessageRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MessageRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool skip = 1;
  bool has_skip() const;
  void clear_skip();
  static const int kSkipFieldNumber = 1;
  bool skip() const;
  void set_skip(bool value);

  // optional bool required = 2;
  bool has_required() const;
  void clear_required();
  static const int kRequiredFieldNumber = 2;
  bool required() const;
  void set_required(bool value);

  // @@protoc_insertion_point(class_scope:validate.MessageRules)
 private:
  void set_has_skip();
  void clear_has_skip();
  void set_has_required();
  void clear_has_required();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool skip_;
  bool required_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RepeatedRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.RepeatedRules) */ {
 public:
  RepeatedRules();
  virtual ~RepeatedRules();

  RepeatedRules(const RepeatedRules& from);

  inline RepeatedRules& operator=(const RepeatedRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepeatedRules(RepeatedRules&& from) noexcept
    : RepeatedRules() {
    *this = ::std::move(from);
  }

  inline RepeatedRules& operator=(RepeatedRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RepeatedRules& default_instance();

  static inline const RepeatedRules* internal_default_instance() {
    return reinterpret_cast<const RepeatedRules*>(
               &_RepeatedRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(RepeatedRules* other);
  friend void swap(RepeatedRules& a, RepeatedRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepeatedRules* New() const PROTOBUF_FINAL { return New(NULL); }

  RepeatedRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RepeatedRules& from);
  void MergeFrom(const RepeatedRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RepeatedRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .validate.FieldRules items = 4;
  bool has_items() const;
  void clear_items();
  static const int kItemsFieldNumber = 4;
  const ::validate::FieldRules& items() const;
  ::validate::FieldRules* mutable_items();
  ::validate::FieldRules* release_items();
  void set_allocated_items(::validate::FieldRules* items);

  // optional uint64 min_items = 1;
  bool has_min_items() const;
  void clear_min_items();
  static const int kMinItemsFieldNumber = 1;
  ::google::protobuf::uint64 min_items() const;
  void set_min_items(::google::protobuf::uint64 value);

  // optional uint64 max_items = 2;
  bool has_max_items() const;
  void clear_max_items();
  static const int kMaxItemsFieldNumber = 2;
  ::google::protobuf::uint64 max_items() const;
  void set_max_items(::google::protobuf::uint64 value);

  // optional bool unique = 3;
  bool has_unique() const;
  void clear_unique();
  static const int kUniqueFieldNumber = 3;
  bool unique() const;
  void set_unique(bool value);

  // @@protoc_insertion_point(class_scope:validate.RepeatedRules)
 private:
  void set_has_min_items();
  void clear_has_min_items();
  void set_has_max_items();
  void clear_has_max_items();
  void set_has_unique();
  void clear_has_unique();
  void set_has_items();
  void clear_has_items();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::validate::FieldRules* items_;
  ::google::protobuf::uint64 min_items_;
  ::google::protobuf::uint64 max_items_;
  bool unique_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.MapRules) */ {
 public:
  MapRules();
  virtual ~MapRules();

  MapRules(const MapRules& from);

  inline MapRules& operator=(const MapRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapRules(MapRules&& from) noexcept
    : MapRules() {
    *this = ::std::move(from);
  }

  inline MapRules& operator=(MapRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapRules& default_instance();

  static inline const MapRules* internal_default_instance() {
    return reinterpret_cast<const MapRules*>(
               &_MapRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(MapRules* other);
  friend void swap(MapRules& a, MapRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapRules* New() const PROTOBUF_FINAL { return New(NULL); }

  MapRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapRules& from);
  void MergeFrom(const MapRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .validate.FieldRules keys = 4;
  bool has_keys() const;
  void clear_keys();
  static const int kKeysFieldNumber = 4;
  const ::validate::FieldRules& keys() const;
  ::validate::FieldRules* mutable_keys();
  ::validate::FieldRules* release_keys();
  void set_allocated_keys(::validate::FieldRules* keys);

  // optional .validate.FieldRules values = 5;
  bool has_values() const;
  void clear_values();
  static const int kValuesFieldNumber = 5;
  const ::validate::FieldRules& values() const;
  ::validate::FieldRules* mutable_values();
  ::validate::FieldRules* release_values();
  void set_allocated_values(::validate::FieldRules* values);

  // optional uint64 min_pairs = 1;
  bool has_min_pairs() const;
  void clear_min_pairs();
  static const int kMinPairsFieldNumber = 1;
  ::google::protobuf::uint64 min_pairs() const;
  void set_min_pairs(::google::protobuf::uint64 value);

  // optional uint64 max_pairs = 2;
  bool has_max_pairs() const;
  void clear_max_pairs();
  static const int kMaxPairsFieldNumber = 2;
  ::google::protobuf::uint64 max_pairs() const;
  void set_max_pairs(::google::protobuf::uint64 value);

  // optional bool no_sparse = 3;
  bool has_no_sparse() const;
  void clear_no_sparse();
  static const int kNoSparseFieldNumber = 3;
  bool no_sparse() const;
  void set_no_sparse(bool value);

  // @@protoc_insertion_point(class_scope:validate.MapRules)
 private:
  void set_has_min_pairs();
  void clear_has_min_pairs();
  void set_has_max_pairs();
  void clear_has_max_pairs();
  void set_has_no_sparse();
  void clear_has_no_sparse();
  void set_has_keys();
  void clear_has_keys();
  void set_has_values();
  void clear_has_values();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::validate::FieldRules* keys_;
  ::validate::FieldRules* values_;
  ::google::protobuf::uint64 min_pairs_;
  ::google::protobuf::uint64 max_pairs_;
  bool no_sparse_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnyRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.AnyRules) */ {
 public:
  AnyRules();
  virtual ~AnyRules();

  AnyRules(const AnyRules& from);

  inline AnyRules& operator=(const AnyRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnyRules(AnyRules&& from) noexcept
    : AnyRules() {
    *this = ::std::move(from);
  }

  inline AnyRules& operator=(AnyRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnyRules& default_instance();

  static inline const AnyRules* internal_default_instance() {
    return reinterpret_cast<const AnyRules*>(
               &_AnyRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(AnyRules* other);
  friend void swap(AnyRules& a, AnyRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnyRules* New() const PROTOBUF_FINAL { return New(NULL); }

  AnyRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnyRules& from);
  void MergeFrom(const AnyRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnyRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string in = 2;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 2;
  const ::std::string& in(int index) const;
  ::std::string* mutable_in(int index);
  void set_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_in(int index, ::std::string&& value);
  #endif
  void set_in(int index, const char* value);
  void set_in(int index, const char* value, size_t size);
  ::std::string* add_in();
  void add_in(const ::std::string& value);
  #if LANG_CXX11
  void add_in(::std::string&& value);
  #endif
  void add_in(const char* value);
  void add_in(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_in();

  // repeated string not_in = 3;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 3;
  const ::std::string& not_in(int index) const;
  ::std::string* mutable_not_in(int index);
  void set_not_in(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_not_in(int index, ::std::string&& value);
  #endif
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const char* value, size_t size);
  ::std::string* add_not_in();
  void add_not_in(const ::std::string& value);
  #if LANG_CXX11
  void add_not_in(::std::string&& value);
  #endif
  void add_not_in(const char* value);
  void add_not_in(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_not_in();

  // optional bool required = 1;
  bool has_required() const;
  void clear_required();
  static const int kRequiredFieldNumber = 1;
  bool required() const;
  void set_required(bool value);

  // @@protoc_insertion_point(class_scope:validate.AnyRules)
 private:
  void set_has_required();
  void clear_has_required();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> in_;
  ::google::protobuf::RepeatedPtrField< ::std::string> not_in_;
  bool required_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DurationRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.DurationRules) */ {
 public:
  DurationRules();
  virtual ~DurationRules();

  DurationRules(const DurationRules& from);

  inline DurationRules& operator=(const DurationRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DurationRules(DurationRules&& from) noexcept
    : DurationRules() {
    *this = ::std::move(from);
  }

  inline DurationRules& operator=(DurationRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DurationRules& default_instance();

  static inline const DurationRules* internal_default_instance() {
    return reinterpret_cast<const DurationRules*>(
               &_DurationRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(DurationRules* other);
  friend void swap(DurationRules& a, DurationRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DurationRules* New() const PROTOBUF_FINAL { return New(NULL); }

  DurationRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DurationRules& from);
  void MergeFrom(const DurationRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DurationRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Duration in = 7;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 7;
  const ::google::protobuf::Duration& in(int index) const;
  ::google::protobuf::Duration* mutable_in(int index);
  ::google::protobuf::Duration* add_in();
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
      mutable_in();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
      in() const;

  // repeated .google.protobuf.Duration not_in = 8;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 8;
  const ::google::protobuf::Duration& not_in(int index) const;
  ::google::protobuf::Duration* mutable_not_in(int index);
  ::google::protobuf::Duration* add_not_in();
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
      mutable_not_in();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
      not_in() const;

  // optional .google.protobuf.Duration const = 2;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 2;
  const ::google::protobuf::Duration& const_() const;
  ::google::protobuf::Duration* mutable_const_();
  ::google::protobuf::Duration* release_const_();
  void set_allocated_const_(::google::protobuf::Duration* const_);

  // optional .google.protobuf.Duration lt = 3;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 3;
  const ::google::protobuf::Duration& lt() const;
  ::google::protobuf::Duration* mutable_lt();
  ::google::protobuf::Duration* release_lt();
  void set_allocated_lt(::google::protobuf::Duration* lt);

  // optional .google.protobuf.Duration lte = 4;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 4;
  const ::google::protobuf::Duration& lte() const;
  ::google::protobuf::Duration* mutable_lte();
  ::google::protobuf::Duration* release_lte();
  void set_allocated_lte(::google::protobuf::Duration* lte);

  // optional .google.protobuf.Duration gt = 5;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 5;
  const ::google::protobuf::Duration& gt() const;
  ::google::protobuf::Duration* mutable_gt();
  ::google::protobuf::Duration* release_gt();
  void set_allocated_gt(::google::protobuf::Duration* gt);

  // optional .google.protobuf.Duration gte = 6;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 6;
  const ::google::protobuf::Duration& gte() const;
  ::google::protobuf::Duration* mutable_gte();
  ::google::protobuf::Duration* release_gte();
  void set_allocated_gte(::google::protobuf::Duration* gte);

  // optional bool required = 1;
  bool has_required() const;
  void clear_required();
  static const int kRequiredFieldNumber = 1;
  bool required() const;
  void set_required(bool value);

  // @@protoc_insertion_point(class_scope:validate.DurationRules)
 private:
  void set_has_required();
  void clear_has_required();
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > in_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > not_in_;
  ::google::protobuf::Duration* const__;
  ::google::protobuf::Duration* lt_;
  ::google::protobuf::Duration* lte_;
  ::google::protobuf::Duration* gt_;
  ::google::protobuf::Duration* gte_;
  bool required_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TimestampRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validate.TimestampRules) */ {
 public:
  TimestampRules();
  virtual ~TimestampRules();

  TimestampRules(const TimestampRules& from);

  inline TimestampRules& operator=(const TimestampRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimestampRules(TimestampRules&& from) noexcept
    : TimestampRules() {
    *this = ::std::move(from);
  }

  inline TimestampRules& operator=(TimestampRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimestampRules& default_instance();

  static inline const TimestampRules* internal_default_instance() {
    return reinterpret_cast<const TimestampRules*>(
               &_TimestampRules_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(TimestampRules* other);
  friend void swap(TimestampRules& a, TimestampRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimestampRules* New() const PROTOBUF_FINAL { return New(NULL); }

  TimestampRules* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimestampRules& from);
  void MergeFrom(const TimestampRules& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimestampRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .google.protobuf.Timestamp const = 2;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 2;
  const ::google::protobuf::Timestamp& const_() const;
  ::google::protobuf::Timestamp* mutable_const_();
  ::google::protobuf::Timestamp* release_const_();
  void set_allocated_const_(::google::protobuf::Timestamp* const_);

  // optional .google.protobuf.Timestamp lt = 3;
  bool has_lt() const;
  void clear_lt();
  static const int kLtFieldNumber = 3;
  const ::google::protobuf::Timestamp& lt() const;
  ::google::protobuf::Timestamp* mutable_lt();
  ::google::protobuf::Timestamp* release_lt();
  void set_allocated_lt(::google::protobuf::Timestamp* lt);

  // optional .google.protobuf.Timestamp lte = 4;
  bool has_lte() const;
  void clear_lte();
  static const int kLteFieldNumber = 4;
  const ::google::protobuf::Timestamp& lte() const;
  ::google::protobuf::Timestamp* mutable_lte();
  ::google::protobuf::Timestamp* release_lte();
  void set_allocated_lte(::google::protobuf::Timestamp* lte);

  // optional .google.protobuf.Timestamp gt = 5;
  bool has_gt() const;
  void clear_gt();
  static const int kGtFieldNumber = 5;
  const ::google::protobuf::Timestamp& gt() const;
  ::google::protobuf::Timestamp* mutable_gt();
  ::google::protobuf::Timestamp* release_gt();
  void set_allocated_gt(::google::protobuf::Timestamp* gt);

  // optional .google.protobuf.Timestamp gte = 6;
  bool has_gte() const;
  void clear_gte();
  static const int kGteFieldNumber = 6;
  const ::google::protobuf::Timestamp& gte() const;
  ::google::protobuf::Timestamp* mutable_gte();
  ::google::protobuf::Timestamp* release_gte();
  void set_allocated_gte(::google::protobuf::Timestamp* gte);

  // optional .google.protobuf.Duration within = 9;
  bool has_within() const;
  void clear_within();
  static const int kWithinFieldNumber = 9;
  const ::google::protobuf::Duration& within() const;
  ::google::protobuf::Duration* mutable_within();
  ::google::protobuf::Duration* release_within();
  void set_allocated_within(::google::protobuf::Duration* within);

  // optional bool required = 1;
  bool has_required() const;
  void clear_required();
  static const int kRequiredFieldNumber = 1;
  bool required() const;
  void set_required(bool value);

  // optional bool lt_now = 7;
  bool has_lt_now() const;
  void clear_lt_now();
  static const int kLtNowFieldNumber = 7;
  bool lt_now() const;
  void set_lt_now(bool value);

  // optional bool gt_now = 8;
  bool has_gt_now() const;
  void clear_gt_now();
  static const int kGtNowFieldNumber = 8;
  bool gt_now() const;
  void set_gt_now(bool value);

  // @@protoc_insertion_point(class_scope:validate.TimestampRules)
 private:
  void set_has_required();
  void clear_has_required();
  void set_has_const_();
  void clear_has_const_();
  void set_has_lt();
  void clear_has_lt();
  void set_has_lte();
  void clear_has_lte();
  void set_has_gt();
  void clear_has_gt();
  void set_has_gte();
  void clear_has_gte();
  void set_has_lt_now();
  void clear_has_lt_now();
  void set_has_gt_now();
  void clear_has_gt_now();
  void set_has_within();
  void clear_has_within();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::Timestamp* const__;
  ::google::protobuf::Timestamp* lt_;
  ::google::protobuf::Timestamp* lte_;
  ::google::protobuf::Timestamp* gt_;
  ::google::protobuf::Timestamp* gte_;
  ::google::protobuf::Duration* within_;
  bool required_;
  bool lt_now_;
  bool gt_now_;
  friend struct protobuf_validate_2eproto::TableStruct;
};
// ===================================================================

static const int kDisabledFieldNumber = 919191;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  disabled;
static const int kRequiredFieldNumber = 919191;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::OneofOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  required;
static const int kRulesFieldNumber = 919191;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::validate::FieldRules >, 11, false >
  rules;

// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FieldRules

// optional .validate.FloatRules float = 1;
inline bool FieldRules::has_float_() const {
  return type_case() == kFloat;
}
inline void FieldRules::set_has_float_() {
  _oneof_case_[0] = kFloat;
}
inline void FieldRules::clear_float_() {
  if (has_float_()) {
    delete type_.float__;
    clear_has_type();
  }
}
inline  const ::validate::FloatRules& FieldRules::float_() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.float)
  return has_float_()
      ? *type_.float__
      : ::validate::FloatRules::default_instance();
}
inline ::validate::FloatRules* FieldRules::mutable_float_() {
  if (!has_float_()) {
    clear_type();
    set_has_float_();
    type_.float__ = new ::validate::FloatRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.float)
  return type_.float__;
}
inline ::validate::FloatRules* FieldRules::release_float_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.float)
  if (has_float_()) {
    clear_has_type();
    ::validate::FloatRules* temp = type_.float__;
    type_.float__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_float_(::validate::FloatRules* float_) {
  clear_type();
  if (float_) {
    set_has_float_();
    type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.float)
}

// optional .validate.DoubleRules double = 2;
inline bool FieldRules::has_double_() const {
  return type_case() == kDouble;
}
inline void FieldRules::set_has_double_() {
  _oneof_case_[0] = kDouble;
}
inline void FieldRules::clear_double_() {
  if (has_double_()) {
    delete type_.double__;
    clear_has_type();
  }
}
inline  const ::validate::DoubleRules& FieldRules::double_() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.double)
  return has_double_()
      ? *type_.double__
      : ::validate::DoubleRules::default_instance();
}
inline ::validate::DoubleRules* FieldRules::mutable_double_() {
  if (!has_double_()) {
    clear_type();
    set_has_double_();
    type_.double__ = new ::validate::DoubleRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.double)
  return type_.double__;
}
inline ::validate::DoubleRules* FieldRules::release_double_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.double)
  if (has_double_()) {
    clear_has_type();
    ::validate::DoubleRules* temp = type_.double__;
    type_.double__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_double_(::validate::DoubleRules* double_) {
  clear_type();
  if (double_) {
    set_has_double_();
    type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.double)
}

// optional .validate.Int32Rules int32 = 3;
inline bool FieldRules::has_int32() const {
  return type_case() == kInt32;
}
inline void FieldRules::set_has_int32() {
  _oneof_case_[0] = kInt32;
}
inline void FieldRules::clear_int32() {
  if (has_int32()) {
    delete type_.int32_;
    clear_has_type();
  }
}
inline  const ::validate::Int32Rules& FieldRules::int32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.int32)
  return has_int32()
      ? *type_.int32_
      : ::validate::Int32Rules::default_instance();
}
inline ::validate::Int32Rules* FieldRules::mutable_int32() {
  if (!has_int32()) {
    clear_type();
    set_has_int32();
    type_.int32_ = new ::validate::Int32Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.int32)
  return type_.int32_;
}
inline ::validate::Int32Rules* FieldRules::release_int32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.int32)
  if (has_int32()) {
    clear_has_type();
    ::validate::Int32Rules* temp = type_.int32_;
    type_.int32_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_int32(::validate::Int32Rules* int32) {
  clear_type();
  if (int32) {
    set_has_int32();
    type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int32)
}

// optional .validate.Int64Rules int64 = 4;
inline bool FieldRules::has_int64() const {
  return type_case() == kInt64;
}
inline void FieldRules::set_has_int64() {
  _oneof_case_[0] = kInt64;
}
inline void FieldRules::clear_int64() {
  if (has_int64()) {
    delete type_.int64_;
    clear_has_type();
  }
}
inline  const ::validate::Int64Rules& FieldRules::int64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.int64)
  return has_int64()
      ? *type_.int64_
      : ::validate::Int64Rules::default_instance();
}
inline ::validate::Int64Rules* FieldRules::mutable_int64() {
  if (!has_int64()) {
    clear_type();
    set_has_int64();
    type_.int64_ = new ::validate::Int64Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.int64)
  return type_.int64_;
}
inline ::validate::Int64Rules* FieldRules::release_int64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.int64)
  if (has_int64()) {
    clear_has_type();
    ::validate::Int64Rules* temp = type_.int64_;
    type_.int64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_int64(::validate::Int64Rules* int64) {
  clear_type();
  if (int64) {
    set_has_int64();
    type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int64)
}

// optional .validate.UInt32Rules uint32 = 5;
inline bool FieldRules::has_uint32() const {
  return type_case() == kUint32;
}
inline void FieldRules::set_has_uint32() {
  _oneof_case_[0] = kUint32;
}
inline void FieldRules::clear_uint32() {
  if (has_uint32()) {
    delete type_.uint32_;
    clear_has_type();
  }
}
inline  const ::validate::UInt32Rules& FieldRules::uint32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.uint32)
  return has_uint32()
      ? *type_.uint32_
      : ::validate::UInt32Rules::default_instance();
}
inline ::validate::UInt32Rules* FieldRules::mutable_uint32() {
  if (!has_uint32()) {
    clear_type();
    set_has_uint32();
    type_.uint32_ = new ::validate::UInt32Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.uint32)
  return type_.uint32_;
}
inline ::validate::UInt32Rules* FieldRules::release_uint32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.uint32)
  if (has_uint32()) {
    clear_has_type();
    ::validate::UInt32Rules* temp = type_.uint32_;
    type_.uint32_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_uint32(::validate::UInt32Rules* uint32) {
  clear_type();
  if (uint32) {
    set_has_uint32();
    type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint32)
}

// optional .validate.UInt64Rules uint64 = 6;
inline bool FieldRules::has_uint64() const {
  return type_case() == kUint64;
}
inline void FieldRules::set_has_uint64() {
  _oneof_case_[0] = kUint64;
}
inline void FieldRules::clear_uint64() {
  if (has_uint64()) {
    delete type_.uint64_;
    clear_has_type();
  }
}
inline  const ::validate::UInt64Rules& FieldRules::uint64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.uint64)
  return has_uint64()
      ? *type_.uint64_
      : ::validate::UInt64Rules::default_instance();
}
inline ::validate::UInt64Rules* FieldRules::mutable_uint64() {
  if (!has_uint64()) {
    clear_type();
    set_has_uint64();
    type_.uint64_ = new ::validate::UInt64Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.uint64)
  return type_.uint64_;
}
inline ::validate::UInt64Rules* FieldRules::release_uint64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.uint64)
  if (has_uint64()) {
    clear_has_type();
    ::validate::UInt64Rules* temp = type_.uint64_;
    type_.uint64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_uint64(::validate::UInt64Rules* uint64) {
  clear_type();
  if (uint64) {
    set_has_uint64();
    type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint64)
}

// optional .validate.SInt32Rules sint32 = 7;
inline bool FieldRules::has_sint32() const {
  return type_case() == kSint32;
}
inline void FieldRules::set_has_sint32() {
  _oneof_case_[0] = kSint32;
}
inline void FieldRules::clear_sint32() {
  if (has_sint32()) {
    delete type_.sint32_;
    clear_has_type();
  }
}
inline  const ::validate::SInt32Rules& FieldRules::sint32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sint32)
  return has_sint32()
      ? *type_.sint32_
      : ::validate::SInt32Rules::default_instance();
}
inline ::validate::SInt32Rules* FieldRules::mutable_sint32() {
  if (!has_sint32()) {
    clear_type();
    set_has_sint32();
    type_.sint32_ = new ::validate::SInt32Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sint32)
  return type_.sint32_;
}
inline ::validate::SInt32Rules* FieldRules::release_sint32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sint32)
  if (has_sint32()) {
    clear_has_type();
    ::validate::SInt32Rules* temp = type_.sint32_;
    type_.sint32_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_sint32(::validate::SInt32Rules* sint32) {
  clear_type();
  if (sint32) {
    set_has_sint32();
    type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint32)
}

// optional .validate.SInt64Rules sint64 = 8;
inline bool FieldRules::has_sint64() const {
  return type_case() == kSint64;
}
inline void FieldRules::set_has_sint64() {
  _oneof_case_[0] = kSint64;
}
inline void FieldRules::clear_sint64() {
  if (has_sint64()) {
    delete type_.sint64_;
    clear_has_type();
  }
}
inline  const ::validate::SInt64Rules& FieldRules::sint64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sint64)
  return has_sint64()
      ? *type_.sint64_
      : ::validate::SInt64Rules::default_instance();
}
inline ::validate::SInt64Rules* FieldRules::mutable_sint64() {
  if (!has_sint64()) {
    clear_type();
    set_has_sint64();
    type_.sint64_ = new ::validate::SInt64Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sint64)
  return type_.sint64_;
}
inline ::validate::SInt64Rules* FieldRules::release_sint64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sint64)
  if (has_sint64()) {
    clear_has_type();
    ::validate::SInt64Rules* temp = type_.sint64_;
    type_.sint64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_sint64(::validate::SInt64Rules* sint64) {
  clear_type();
  if (sint64) {
    set_has_sint64();
    type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint64)
}

// optional .validate.Fixed32Rules fixed32 = 9;
inline bool FieldRules::has_fixed32() const {
  return type_case() == kFixed32;
}
inline void FieldRules::set_has_fixed32() {
  _oneof_case_[0] = kFixed32;
}
inline void FieldRules::clear_fixed32() {
  if (has_fixed32()) {
    delete type_.fixed32_;
    clear_has_type();
  }
}
inline  const ::validate::Fixed32Rules& FieldRules::fixed32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.fixed32)
  return has_fixed32()
      ? *type_.fixed32_
      : ::validate::Fixed32Rules::default_instance();
}
inline ::validate::Fixed32Rules* FieldRules::mutable_fixed32() {
  if (!has_fixed32()) {
    clear_type();
    set_has_fixed32();
    type_.fixed32_ = new ::validate::Fixed32Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.fixed32)
  return type_.fixed32_;
}
inline ::validate::Fixed32Rules* FieldRules::release_fixed32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.fixed32)
  if (has_fixed32()) {
    clear_has_type();
    ::validate::Fixed32Rules* temp = type_.fixed32_;
    type_.fixed32_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_fixed32(::validate::Fixed32Rules* fixed32) {
  clear_type();
  if (fixed32) {
    set_has_fixed32();
    type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed32)
}

// optional .validate.Fixed64Rules fixed64 = 10;
inline bool FieldRules::has_fixed64() const {
  return type_case() == kFixed64;
}
inline void FieldRules::set_has_fixed64() {
  _oneof_case_[0] = kFixed64;
}
inline void FieldRules::clear_fixed64() {
  if (has_fixed64()) {
    delete type_.fixed64_;
    clear_has_type();
  }
}
inline  const ::validate::Fixed64Rules& FieldRules::fixed64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.fixed64)
  return has_fixed64()
      ? *type_.fixed64_
      : ::validate::Fixed64Rules::default_instance();
}
inline ::validate::Fixed64Rules* FieldRules::mutable_fixed64() {
  if (!has_fixed64()) {
    clear_type();
    set_has_fixed64();
    type_.fixed64_ = new ::validate::Fixed64Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.fixed64)
  return type_.fixed64_;
}
inline ::validate::Fixed64Rules* FieldRules::release_fixed64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.fixed64)
  if (has_fixed64()) {
    clear_has_type();
    ::validate::Fixed64Rules* temp = type_.fixed64_;
    type_.fixed64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_fixed64(::validate::Fixed64Rules* fixed64) {
  clear_type();
  if (fixed64) {
    set_has_fixed64();
    type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed64)
}

// optional .validate.SFixed32Rules sfixed32 = 11;
inline bool FieldRules::has_sfixed32() const {
  return type_case() == kSfixed32;
}
inline void FieldRules::set_has_sfixed32() {
  _oneof_case_[0] = kSfixed32;
}
inline void FieldRules::clear_sfixed32() {
  if (has_sfixed32()) {
    delete type_.sfixed32_;
    clear_has_type();
  }
}
inline  const ::validate::SFixed32Rules& FieldRules::sfixed32() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sfixed32)
  return has_sfixed32()
      ? *type_.sfixed32_
      : ::validate::SFixed32Rules::default_instance();
}
inline ::validate::SFixed32Rules* FieldRules::mutable_sfixed32() {
  if (!has_sfixed32()) {
    clear_type();
    set_has_sfixed32();
    type_.sfixed32_ = new ::validate::SFixed32Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sfixed32)
  return type_.sfixed32_;
}
inline ::validate::SFixed32Rules* FieldRules::release_sfixed32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sfixed32)
  if (has_sfixed32()) {
    clear_has_type();
    ::validate::SFixed32Rules* temp = type_.sfixed32_;
    type_.sfixed32_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_sfixed32(::validate::SFixed32Rules* sfixed32) {
  clear_type();
  if (sfixed32) {
    set_has_sfixed32();
    type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed32)
}

// optional .validate.SFixed64Rules sfixed64 = 12;
inline bool FieldRules::has_sfixed64() const {
  return type_case() == kSfixed64;
}
inline void FieldRules::set_has_sfixed64() {
  _oneof_case_[0] = kSfixed64;
}
inline void FieldRules::clear_sfixed64() {
  if (has_sfixed64()) {
    delete type_.sfixed64_;
    clear_has_type();
  }
}
inline  const ::validate::SFixed64Rules& FieldRules::sfixed64() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sfixed64)
  return has_sfixed64()
      ? *type_.sfixed64_
      : ::validate::SFixed64Rules::default_instance();
}
inline ::validate::SFixed64Rules* FieldRules::mutable_sfixed64() {
  if (!has_sfixed64()) {
    clear_type();
    set_has_sfixed64();
    type_.sfixed64_ = new ::validate::SFixed64Rules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sfixed64)
  return type_.sfixed64_;
}
inline ::validate::SFixed64Rules* FieldRules::release_sfixed64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sfixed64)
  if (has_sfixed64()) {
    clear_has_type();
    ::validate::SFixed64Rules* temp = type_.sfixed64_;
    type_.sfixed64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_sfixed64(::validate::SFixed64Rules* sfixed64) {
  clear_type();
  if (sfixed64) {
    set_has_sfixed64();
    type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed64)
}

// optional .validate.BoolRules bool = 13;
inline bool FieldRules::has_bool_() const {
  return type_case() == kBool;
}
inline void FieldRules::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void FieldRules::clear_bool_() {
  if (has_bool_()) {
    delete type_.bool__;
    clear_has_type();
  }
}
inline  const ::validate::BoolRules& FieldRules::bool_() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.bool)
  return has_bool_()
      ? *type_.bool__
      : ::validate::BoolRules::default_instance();
}
inline ::validate::BoolRules* FieldRules::mutable_bool_() {
  if (!has_bool_()) {
    clear_type();
    set_has_bool_();
    type_.bool__ = new ::validate::BoolRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.bool)
  return type_.bool__;
}
inline ::validate::BoolRules* FieldRules::release_bool_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.bool)
  if (has_bool_()) {
    clear_has_type();
    ::validate::BoolRules* temp = type_.bool__;
    type_.bool__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_bool_(::validate::BoolRules* bool_) {
  clear_type();
  if (bool_) {
    set_has_bool_();
    type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bool)
}

// optional .validate.StringRules string = 14;
inline bool FieldRules::has_string() const {
  return type_case() == kString;
}
inline void FieldRules::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void FieldRules::clear_string() {
  if (has_string()) {
    delete type_.string_;
    clear_has_type();
  }
}
inline  const ::validate::StringRules& FieldRules::string() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.string)
  return has_string()
      ? *type_.string_
      : ::validate::StringRules::default_instance();
}
inline ::validate::StringRules* FieldRules::mutable_string() {
  if (!has_string()) {
    clear_type();
    set_has_string();
    type_.string_ = new ::validate::StringRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.string)
  return type_.string_;
}
inline ::validate::StringRules* FieldRules::release_string() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.string)
  if (has_string()) {
    clear_has_type();
    ::validate::StringRules* temp = type_.string_;
    type_.string_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_string(::validate::StringRules* string) {
  clear_type();
  if (string) {
    set_has_string();
    type_.string_ = string;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.string)
}

// optional .validate.BytesRules bytes = 15;
inline bool FieldRules::has_bytes() const {
  return type_case() == kBytes;
}
inline void FieldRules::set_has_bytes() {
  _oneof_case_[0] = kBytes;
}
inline void FieldRules::clear_bytes() {
  if (has_bytes()) {
    delete type_.bytes_;
    clear_has_type();
  }
}
inline  const ::validate::BytesRules& FieldRules::bytes() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.bytes)
  return has_bytes()
      ? *type_.bytes_
      : ::validate::BytesRules::default_instance();
}
inline ::validate::BytesRules* FieldRules::mutable_bytes() {
  if (!has_bytes()) {
    clear_type();
    set_has_bytes();
    type_.bytes_ = new ::validate::BytesRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.bytes)
  return type_.bytes_;
}
inline ::validate::BytesRules* FieldRules::release_bytes() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.bytes)
  if (has_bytes()) {
    clear_has_type();
    ::validate::BytesRules* temp = type_.bytes_;
    type_.bytes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_bytes(::validate::BytesRules* bytes) {
  clear_type();
  if (bytes) {
    set_has_bytes();
    type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bytes)
}

// optional .validate.EnumRules enum = 16;
inline bool FieldRules::has_enum_() const {
  return type_case() == kEnum;
}
inline void FieldRules::set_has_enum_() {
  _oneof_case_[0] = kEnum;
}
inline void FieldRules::clear_enum_() {
  if (has_enum_()) {
    delete type_.enum__;
    clear_has_type();
  }
}
inline  const ::validate::EnumRules& FieldRules::enum_() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.enum)
  return has_enum_()
      ? *type_.enum__
      : ::validate::EnumRules::default_instance();
}
inline ::validate::EnumRules* FieldRules::mutable_enum_() {
  if (!has_enum_()) {
    clear_type();
    set_has_enum_();
    type_.enum__ = new ::validate::EnumRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.enum)
  return type_.enum__;
}
inline ::validate::EnumRules* FieldRules::release_enum_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.enum)
  if (has_enum_()) {
    clear_has_type();
    ::validate::EnumRules* temp = type_.enum__;
    type_.enum__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_enum_(::validate::EnumRules* enum_) {
  clear_type();
  if (enum_) {
    set_has_enum_();
    type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.enum)
}

// optional .validate.MessageRules message = 17;
inline bool FieldRules::has_message() const {
  return type_case() == kMessage;
}
inline void FieldRules::set_has_message() {
  _oneof_case_[0] = kMessage;
}
inline void FieldRules::clear_message() {
  if (has_message()) {
    delete type_.message_;
    clear_has_type();
  }
}
inline  const ::validate::MessageRules& FieldRules::message() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.message)
  return has_message()
      ? *type_.message_
      : ::validate::MessageRules::default_instance();
}
inline ::validate::MessageRules* FieldRules::mutable_message() {
  if (!has_message()) {
    clear_type();
    set_has_message();
    type_.message_ = new ::validate::MessageRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.message)
  return type_.message_;
}
inline ::validate::MessageRules* FieldRules::release_message() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.message)
  if (has_message()) {
    clear_has_type();
    ::validate::MessageRules* temp = type_.message_;
    type_.message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_message(::validate::MessageRules* message) {
  clear_type();
  if (message) {
    set_has_message();
    type_.message_ = message;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.message)
}

// optional .validate.RepeatedRules repeated = 18;
inline bool FieldRules::has_repeated() const {
  return type_case() == kRepeated;
}
inline void FieldRules::set_has_repeated() {
  _oneof_case_[0] = kRepeated;
}
inline void FieldRules::clear_repeated() {
  if (has_repeated()) {
    delete type_.repeated_;
    clear_has_type();
  }
}
inline  const ::validate::RepeatedRules& FieldRules::repeated() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.repeated)
  return has_repeated()
      ? *type_.repeated_
      : ::validate::RepeatedRules::default_instance();
}
inline ::validate::RepeatedRules* FieldRules::mutable_repeated() {
  if (!has_repeated()) {
    clear_type();
    set_has_repeated();
    type_.repeated_ = new ::validate::RepeatedRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.repeated)
  return type_.repeated_;
}
inline ::validate::RepeatedRules* FieldRules::release_repeated() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.repeated)
  if (has_repeated()) {
    clear_has_type();
    ::validate::RepeatedRules* temp = type_.repeated_;
    type_.repeated_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_repeated(::validate::RepeatedRules* repeated) {
  clear_type();
  if (repeated) {
    set_has_repeated();
    type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.repeated)
}

// optional .validate.MapRules map = 19;
inline bool FieldRules::has_map() const {
  return type_case() == kMap;
}
inline void FieldRules::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void FieldRules::clear_map() {
  if (has_map()) {
    delete type_.map_;
    clear_has_type();
  }
}
inline  const ::validate::MapRules& FieldRules::map() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.map)
  return has_map()
      ? *type_.map_
      : ::validate::MapRules::default_instance();
}
inline ::validate::MapRules* FieldRules::mutable_map() {
  if (!has_map()) {
    clear_type();
    set_has_map();
    type_.map_ = new ::validate::MapRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.map)
  return type_.map_;
}
inline ::validate::MapRules* FieldRules::release_map() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.map)
  if (has_map()) {
    clear_has_type();
    ::validate::MapRules* temp = type_.map_;
    type_.map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_map(::validate::MapRules* map) {
  clear_type();
  if (map) {
    set_has_map();
    type_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.map)
}

// optional .validate.AnyRules any = 20;
inline bool FieldRules::has_any() const {
  return type_case() == kAny;
}
inline void FieldRules::set_has_any() {
  _oneof_case_[0] = kAny;
}
inline void FieldRules::clear_any() {
  if (has_any()) {
    delete type_.any_;
    clear_has_type();
  }
}
inline  const ::validate::AnyRules& FieldRules::any() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.any)
  return has_any()
      ? *type_.any_
      : ::validate::AnyRules::default_instance();
}
inline ::validate::AnyRules* FieldRules::mutable_any() {
  if (!has_any()) {
    clear_type();
    set_has_any();
    type_.any_ = new ::validate::AnyRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.any)
  return type_.any_;
}
inline ::validate::AnyRules* FieldRules::release_any() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.any)
  if (has_any()) {
    clear_has_type();
    ::validate::AnyRules* temp = type_.any_;
    type_.any_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_any(::validate::AnyRules* any) {
  clear_type();
  if (any) {
    set_has_any();
    type_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.any)
}

// optional .validate.DurationRules duration = 21;
inline bool FieldRules::has_duration() const {
  return type_case() == kDuration;
}
inline void FieldRules::set_has_duration() {
  _oneof_case_[0] = kDuration;
}
inline void FieldRules::clear_duration() {
  if (has_duration()) {
    delete type_.duration_;
    clear_has_type();
  }
}
inline  const ::validate::DurationRules& FieldRules::duration() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.duration)
  return has_duration()
      ? *type_.duration_
      : ::validate::DurationRules::default_instance();
}
inline ::validate::DurationRules* FieldRules::mutable_duration() {
  if (!has_duration()) {
    clear_type();
    set_has_duration();
    type_.duration_ = new ::validate::DurationRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.duration)
  return type_.duration_;
}
inline ::validate::DurationRules* FieldRules::release_duration() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.duration)
  if (has_duration()) {
    clear_has_type();
    ::validate::DurationRules* temp = type_.duration_;
    type_.duration_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_duration(::validate::DurationRules* duration) {
  clear_type();
  if (duration) {
    set_has_duration();
    type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.duration)
}

// optional .validate.TimestampRules timestamp = 22;
inline bool FieldRules::has_timestamp() const {
  return type_case() == kTimestamp;
}
inline void FieldRules::set_has_timestamp() {
  _oneof_case_[0] = kTimestamp;
}
inline void FieldRules::clear_timestamp() {
  if (has_timestamp()) {
    delete type_.timestamp_;
    clear_has_type();
  }
}
inline  const ::validate::TimestampRules& FieldRules::timestamp() const {
  // @@protoc_insertion_point(field_get:validate.FieldRules.timestamp)
  return has_timestamp()
      ? *type_.timestamp_
      : ::validate::TimestampRules::default_instance();
}
inline ::validate::TimestampRules* FieldRules::mutable_timestamp() {
  if (!has_timestamp()) {
    clear_type();
    set_has_timestamp();
    type_.timestamp_ = new ::validate::TimestampRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.timestamp)
  return type_.timestamp_;
}
inline ::validate::TimestampRules* FieldRules::release_timestamp() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.timestamp)
  if (has_timestamp()) {
    clear_has_type();
    ::validate::TimestampRules* temp = type_.timestamp_;
    type_.timestamp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FieldRules::set_allocated_timestamp(::validate::TimestampRules* timestamp) {
  clear_type();
  if (timestamp) {
    set_has_timestamp();
    type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.timestamp)
}

inline bool FieldRules::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void FieldRules::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline FieldRules::TypeCase FieldRules::type_case() const {
  return FieldRules::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FloatRules

// optional float const = 1;
inline bool FloatRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatRules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatRules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatRules::clear_const_() {
  const__ = 0;
  clear_has_const_();
}
inline float FloatRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.const)
  return const__;
}
inline void FloatRules::set_const_(float value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.const)
}

// optional float lt = 2;
inline bool FloatRules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloatRules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloatRules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloatRules::clear_lt() {
  lt_ = 0;
  clear_has_lt();
}
inline float FloatRules::lt() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.lt)
  return lt_;
}
inline void FloatRules::set_lt(float value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.lt)
}

// optional float lte = 3;
inline bool FloatRules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FloatRules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FloatRules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FloatRules::clear_lte() {
  lte_ = 0;
  clear_has_lte();
}
inline float FloatRules::lte() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.lte)
  return lte_;
}
inline void FloatRules::set_lte(float value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.lte)
}

// optional float gt = 4;
inline bool FloatRules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FloatRules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FloatRules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FloatRules::clear_gt() {
  gt_ = 0;
  clear_has_gt();
}
inline float FloatRules::gt() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.gt)
  return gt_;
}
inline void FloatRules::set_gt(float value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.gt)
}

// optional float gte = 5;
inline bool FloatRules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FloatRules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FloatRules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FloatRules::clear_gte() {
  gte_ = 0;
  clear_has_gte();
}
inline float FloatRules::gte() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.gte)
  return gte_;
}
inline void FloatRules::set_gte(float value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.FloatRules.gte)
}

// repeated float in = 6;
inline int FloatRules::in_size() const {
  return in_.size();
}
inline void FloatRules::clear_in() {
  in_.Clear();
}
inline float FloatRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.in)
  return in_.Get(index);
}
inline void FloatRules::set_in(int index, float value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.FloatRules.in)
}
inline void FloatRules::add_in(float value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.FloatRules.in)
}
inline const ::google::protobuf::RepeatedField< float >&
FloatRules::in() const {
  // @@protoc_insertion_point(field_list:validate.FloatRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.FloatRules.in)
  return &in_;
}

// repeated float not_in = 7;
inline int FloatRules::not_in_size() const {
  return not_in_.size();
}
inline void FloatRules::clear_not_in() {
  not_in_.Clear();
}
inline float FloatRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.not_in)
  return not_in_.Get(index);
}
inline void FloatRules::set_not_in(int index, float value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.FloatRules.not_in)
}
inline void FloatRules::add_not_in(float value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.FloatRules.not_in)
}
inline const ::google::protobuf::RepeatedField< float >&
FloatRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.FloatRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.FloatRules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// DoubleRules

// optional double const = 1;
inline bool DoubleRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleRules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubleRules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubleRules::clear_const_() {
  const__ = 0;
  clear_has_const_();
}
inline double DoubleRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.const)
  return const__;
}
inline void DoubleRules::set_const_(double value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.const)
}

// optional double lt = 2;
inline bool DoubleRules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoubleRules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoubleRules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoubleRules::clear_lt() {
  lt_ = 0;
  clear_has_lt();
}
inline double DoubleRules::lt() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.lt)
  return lt_;
}
inline void DoubleRules::set_lt(double value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.lt)
}

// optional double lte = 3;
inline bool DoubleRules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DoubleRules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DoubleRules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DoubleRules::clear_lte() {
  lte_ = 0;
  clear_has_lte();
}
inline double DoubleRules::lte() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.lte)
  return lte_;
}
inline void DoubleRules::set_lte(double value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.lte)
}

// optional double gt = 4;
inline bool DoubleRules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DoubleRules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DoubleRules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DoubleRules::clear_gt() {
  gt_ = 0;
  clear_has_gt();
}
inline double DoubleRules::gt() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.gt)
  return gt_;
}
inline void DoubleRules::set_gt(double value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.gt)
}

// optional double gte = 5;
inline bool DoubleRules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DoubleRules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DoubleRules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DoubleRules::clear_gte() {
  gte_ = 0;
  clear_has_gte();
}
inline double DoubleRules::gte() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.gte)
  return gte_;
}
inline void DoubleRules::set_gte(double value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.gte)
}

// repeated double in = 6;
inline int DoubleRules::in_size() const {
  return in_.size();
}
inline void DoubleRules::clear_in() {
  in_.Clear();
}
inline double DoubleRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.in)
  return in_.Get(index);
}
inline void DoubleRules::set_in(int index, double value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.DoubleRules.in)
}
inline void DoubleRules::add_in(double value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.DoubleRules.in)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleRules::in() const {
  // @@protoc_insertion_point(field_list:validate.DoubleRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.DoubleRules.in)
  return &in_;
}

// repeated double not_in = 7;
inline int DoubleRules::not_in_size() const {
  return not_in_.size();
}
inline void DoubleRules::clear_not_in() {
  not_in_.Clear();
}
inline double DoubleRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.not_in)
  return not_in_.Get(index);
}
inline void DoubleRules::set_not_in(int index, double value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.DoubleRules.not_in)
}
inline void DoubleRules::add_not_in(double value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.DoubleRules.not_in)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.DoubleRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.DoubleRules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// Int32Rules

// optional int32 const = 1;
inline bool Int32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Int32Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Int32Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Int32Rules::clear_const_() {
  const__ = 0;
  clear_has_const_();
}
inline ::google::protobuf::int32 Int32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.const)
  return const__;
}
inline void Int32Rules::set_const_(::google::protobuf::int32 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.const)
}

// optional int32 lt = 2;
inline bool Int32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Int32Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Int32Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Int32Rules::clear_lt() {
  lt_ = 0;
  clear_has_lt();
}
inline ::google::protobuf::int32 Int32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.lt)
  return lt_;
}
inline void Int32Rules::set_lt(::google::protobuf::int32 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.lt)
}

// optional int32 lte = 3;
inline bool Int32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Int32Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Int32Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Int32Rules::clear_lte() {
  lte_ = 0;
  clear_has_lte();
}
inline ::google::protobuf::int32 Int32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.lte)
  return lte_;
}
inline void Int32Rules::set_lte(::google::protobuf::int32 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.lte)
}

// optional int32 gt = 4;
inline bool Int32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Int32Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Int32Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Int32Rules::clear_gt() {
  gt_ = 0;
  clear_has_gt();
}
inline ::google::protobuf::int32 Int32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.gt)
  return gt_;
}
inline void Int32Rules::set_gt(::google::protobuf::int32 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.gt)
}

// optional int32 gte = 5;
inline bool Int32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Int32Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Int32Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Int32Rules::clear_gte() {
  gte_ = 0;
  clear_has_gte();
}
inline ::google::protobuf::int32 Int32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.gte)
  return gte_;
}
inline void Int32Rules::set_gte(::google::protobuf::int32 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.gte)
}

// repeated int32 in = 6;
inline int Int32Rules::in_size() const {
  return in_.size();
}
inline void Int32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 Int32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.in)
  return in_.Get(index);
}
inline void Int32Rules::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int32Rules.in)
}
inline void Int32Rules::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Int32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Int32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.Int32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Int32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Int32Rules.in)
  return &in_;
}

// repeated int32 not_in = 7;
inline int Int32Rules::not_in_size() const {
  return not_in_.size();
}
inline void Int32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 Int32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.not_in)
  return not_in_.Get(index);
}
inline void Int32Rules::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int32Rules.not_in)
}
inline void Int32Rules::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Int32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Int32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.Int32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Int32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Int32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// Int64Rules

// optional int64 const = 1;
inline bool Int64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Int64Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Int64Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Int64Rules::clear_const_() {
  const__ = GOOGLE_LONGLONG(0);
  clear_has_const_();
}
inline ::google::protobuf::int64 Int64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.const)
  return const__;
}
inline void Int64Rules::set_const_(::google::protobuf::int64 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.const)
}

// optional int64 lt = 2;
inline bool Int64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Int64Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Int64Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Int64Rules::clear_lt() {
  lt_ = GOOGLE_LONGLONG(0);
  clear_has_lt();
}
inline ::google::protobuf::int64 Int64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.lt)
  return lt_;
}
inline void Int64Rules::set_lt(::google::protobuf::int64 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.lt)
}

// optional int64 lte = 3;
inline bool Int64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Int64Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Int64Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Int64Rules::clear_lte() {
  lte_ = GOOGLE_LONGLONG(0);
  clear_has_lte();
}
inline ::google::protobuf::int64 Int64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.lte)
  return lte_;
}
inline void Int64Rules::set_lte(::google::protobuf::int64 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.lte)
}

// optional int64 gt = 4;
inline bool Int64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Int64Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Int64Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Int64Rules::clear_gt() {
  gt_ = GOOGLE_LONGLONG(0);
  clear_has_gt();
}
inline ::google::protobuf::int64 Int64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.gt)
  return gt_;
}
inline void Int64Rules::set_gt(::google::protobuf::int64 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.gt)
}

// optional int64 gte = 5;
inline bool Int64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Int64Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Int64Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Int64Rules::clear_gte() {
  gte_ = GOOGLE_LONGLONG(0);
  clear_has_gte();
}
inline ::google::protobuf::int64 Int64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.gte)
  return gte_;
}
inline void Int64Rules::set_gte(::google::protobuf::int64 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.gte)
}

// repeated int64 in = 6;
inline int Int64Rules::in_size() const {
  return in_.size();
}
inline void Int64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int64 Int64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.in)
  return in_.Get(index);
}
inline void Int64Rules::set_in(int index, ::google::protobuf::int64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int64Rules.in)
}
inline void Int64Rules::add_in(::google::protobuf::int64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Int64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.Int64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Int64Rules.in)
  return &in_;
}

// repeated int64 not_in = 7;
inline int Int64Rules::not_in_size() const {
  return not_in_.size();
}
inline void Int64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int64 Int64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.not_in)
  return not_in_.Get(index);
}
inline void Int64Rules::set_not_in(int index, ::google::protobuf::int64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int64Rules.not_in)
}
inline void Int64Rules::add_not_in(::google::protobuf::int64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Int64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.Int64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Int64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// UInt32Rules

// optional uint32 const = 1;
inline bool UInt32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UInt32Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UInt32Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UInt32Rules::clear_const_() {
  const__ = 0u;
  clear_has_const_();
}
inline ::google::protobuf::uint32 UInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.const)
  return const__;
}
inline void UInt32Rules::set_const_(::google::protobuf::uint32 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.const)
}

// optional uint32 lt = 2;
inline bool UInt32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UInt32Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UInt32Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UInt32Rules::clear_lt() {
  lt_ = 0u;
  clear_has_lt();
}
inline ::google::protobuf::uint32 UInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.lt)
  return lt_;
}
inline void UInt32Rules::set_lt(::google::protobuf::uint32 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.lt)
}

// optional uint32 lte = 3;
inline bool UInt32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UInt32Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UInt32Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UInt32Rules::clear_lte() {
  lte_ = 0u;
  clear_has_lte();
}
inline ::google::protobuf::uint32 UInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.lte)
  return lte_;
}
inline void UInt32Rules::set_lte(::google::protobuf::uint32 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.lte)
}

// optional uint32 gt = 4;
inline bool UInt32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UInt32Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UInt32Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UInt32Rules::clear_gt() {
  gt_ = 0u;
  clear_has_gt();
}
inline ::google::protobuf::uint32 UInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.gt)
  return gt_;
}
inline void UInt32Rules::set_gt(::google::protobuf::uint32 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.gt)
}

// optional uint32 gte = 5;
inline bool UInt32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UInt32Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UInt32Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UInt32Rules::clear_gte() {
  gte_ = 0u;
  clear_has_gte();
}
inline ::google::protobuf::uint32 UInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.gte)
  return gte_;
}
inline void UInt32Rules::set_gte(::google::protobuf::uint32 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.gte)
}

// repeated uint32 in = 6;
inline int UInt32Rules::in_size() const {
  return in_.size();
}
inline void UInt32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint32 UInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.in)
  return in_.Get(index);
}
inline void UInt32Rules::set_in(int index, ::google::protobuf::uint32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.in)
}
inline void UInt32Rules::add_in(::google::protobuf::uint32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UInt32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.UInt32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UInt32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt32Rules.in)
  return &in_;
}

// repeated uint32 not_in = 7;
inline int UInt32Rules::not_in_size() const {
  return not_in_.size();
}
inline void UInt32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint32 UInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.not_in)
  return not_in_.Get(index);
}
inline void UInt32Rules::set_not_in(int index, ::google::protobuf::uint32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.not_in)
}
inline void UInt32Rules::add_not_in(::google::protobuf::uint32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UInt32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.UInt32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UInt32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// UInt64Rules

// optional uint64 const = 1;
inline bool UInt64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UInt64Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UInt64Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UInt64Rules::clear_const_() {
  const__ = GOOGLE_ULONGLONG(0);
  clear_has_const_();
}
inline ::google::protobuf::uint64 UInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.const)
  return const__;
}
inline void UInt64Rules::set_const_(::google::protobuf::uint64 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.const)
}

// optional uint64 lt = 2;
inline bool UInt64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UInt64Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UInt64Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UInt64Rules::clear_lt() {
  lt_ = GOOGLE_ULONGLONG(0);
  clear_has_lt();
}
inline ::google::protobuf::uint64 UInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.lt)
  return lt_;
}
inline void UInt64Rules::set_lt(::google::protobuf::uint64 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.lt)
}

// optional uint64 lte = 3;
inline bool UInt64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UInt64Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UInt64Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UInt64Rules::clear_lte() {
  lte_ = GOOGLE_ULONGLONG(0);
  clear_has_lte();
}
inline ::google::protobuf::uint64 UInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.lte)
  return lte_;
}
inline void UInt64Rules::set_lte(::google::protobuf::uint64 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.lte)
}

// optional uint64 gt = 4;
inline bool UInt64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UInt64Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UInt64Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UInt64Rules::clear_gt() {
  gt_ = GOOGLE_ULONGLONG(0);
  clear_has_gt();
}
inline ::google::protobuf::uint64 UInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.gt)
  return gt_;
}
inline void UInt64Rules::set_gt(::google::protobuf::uint64 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.gt)
}

// optional uint64 gte = 5;
inline bool UInt64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UInt64Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UInt64Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UInt64Rules::clear_gte() {
  gte_ = GOOGLE_ULONGLONG(0);
  clear_has_gte();
}
inline ::google::protobuf::uint64 UInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.gte)
  return gte_;
}
inline void UInt64Rules::set_gte(::google::protobuf::uint64 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.gte)
}

// repeated uint64 in = 6;
inline int UInt64Rules::in_size() const {
  return in_.size();
}
inline void UInt64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint64 UInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.in)
  return in_.Get(index);
}
inline void UInt64Rules::set_in(int index, ::google::protobuf::uint64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.in)
}
inline void UInt64Rules::add_in(::google::protobuf::uint64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UInt64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.UInt64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UInt64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt64Rules.in)
  return &in_;
}

// repeated uint64 not_in = 7;
inline int UInt64Rules::not_in_size() const {
  return not_in_.size();
}
inline void UInt64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint64 UInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.not_in)
  return not_in_.Get(index);
}
inline void UInt64Rules::set_not_in(int index, ::google::protobuf::uint64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.not_in)
}
inline void UInt64Rules::add_not_in(::google::protobuf::uint64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UInt64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.UInt64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UInt64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// SInt32Rules

// optional sint32 const = 1;
inline bool SInt32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SInt32Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SInt32Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SInt32Rules::clear_const_() {
  const__ = 0;
  clear_has_const_();
}
inline ::google::protobuf::int32 SInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.const)
  return const__;
}
inline void SInt32Rules::set_const_(::google::protobuf::int32 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.const)
}

// optional sint32 lt = 2;
inline bool SInt32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SInt32Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SInt32Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SInt32Rules::clear_lt() {
  lt_ = 0;
  clear_has_lt();
}
inline ::google::protobuf::int32 SInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.lt)
  return lt_;
}
inline void SInt32Rules::set_lt(::google::protobuf::int32 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.lt)
}

// optional sint32 lte = 3;
inline bool SInt32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SInt32Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SInt32Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SInt32Rules::clear_lte() {
  lte_ = 0;
  clear_has_lte();
}
inline ::google::protobuf::int32 SInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.lte)
  return lte_;
}
inline void SInt32Rules::set_lte(::google::protobuf::int32 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.lte)
}

// optional sint32 gt = 4;
inline bool SInt32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SInt32Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SInt32Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SInt32Rules::clear_gt() {
  gt_ = 0;
  clear_has_gt();
}
inline ::google::protobuf::int32 SInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.gt)
  return gt_;
}
inline void SInt32Rules::set_gt(::google::protobuf::int32 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.gt)
}

// optional sint32 gte = 5;
inline bool SInt32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SInt32Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SInt32Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SInt32Rules::clear_gte() {
  gte_ = 0;
  clear_has_gte();
}
inline ::google::protobuf::int32 SInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.gte)
  return gte_;
}
inline void SInt32Rules::set_gte(::google::protobuf::int32 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.gte)
}

// repeated sint32 in = 6;
inline int SInt32Rules::in_size() const {
  return in_.size();
}
inline void SInt32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 SInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.in)
  return in_.Get(index);
}
inline void SInt32Rules::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.in)
}
inline void SInt32Rules::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SInt32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.SInt32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SInt32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt32Rules.in)
  return &in_;
}

// repeated sint32 not_in = 7;
inline int SInt32Rules::not_in_size() const {
  return not_in_.size();
}
inline void SInt32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 SInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.not_in)
  return not_in_.Get(index);
}
inline void SInt32Rules::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.not_in)
}
inline void SInt32Rules::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SInt32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.SInt32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SInt32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// SInt64Rules

// optional sint64 const = 1;
inline bool SInt64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SInt64Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SInt64Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SInt64Rules::clear_const_() {
  const__ = GOOGLE_LONGLONG(0);
  clear_has_const_();
}
inline ::google::protobuf::int64 SInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.const)
  return const__;
}
inline void SInt64Rules::set_const_(::google::protobuf::int64 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.const)
}

// optional sint64 lt = 2;
inline bool SInt64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SInt64Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SInt64Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SInt64Rules::clear_lt() {
  lt_ = GOOGLE_LONGLONG(0);
  clear_has_lt();
}
inline ::google::protobuf::int64 SInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.lt)
  return lt_;
}
inline void SInt64Rules::set_lt(::google::protobuf::int64 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.lt)
}

// optional sint64 lte = 3;
inline bool SInt64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SInt64Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SInt64Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SInt64Rules::clear_lte() {
  lte_ = GOOGLE_LONGLONG(0);
  clear_has_lte();
}
inline ::google::protobuf::int64 SInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.lte)
  return lte_;
}
inline void SInt64Rules::set_lte(::google::protobuf::int64 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.lte)
}

// optional sint64 gt = 4;
inline bool SInt64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SInt64Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SInt64Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SInt64Rules::clear_gt() {
  gt_ = GOOGLE_LONGLONG(0);
  clear_has_gt();
}
inline ::google::protobuf::int64 SInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.gt)
  return gt_;
}
inline void SInt64Rules::set_gt(::google::protobuf::int64 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.gt)
}

// optional sint64 gte = 5;
inline bool SInt64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SInt64Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SInt64Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SInt64Rules::clear_gte() {
  gte_ = GOOGLE_LONGLONG(0);
  clear_has_gte();
}
inline ::google::protobuf::int64 SInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.gte)
  return gte_;
}
inline void SInt64Rules::set_gte(::google::protobuf::int64 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.gte)
}

// repeated sint64 in = 6;
inline int SInt64Rules::in_size() const {
  return in_.size();
}
inline void SInt64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int64 SInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.in)
  return in_.Get(index);
}
inline void SInt64Rules::set_in(int index, ::google::protobuf::int64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.in)
}
inline void SInt64Rules::add_in(::google::protobuf::int64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SInt64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.SInt64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SInt64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt64Rules.in)
  return &in_;
}

// repeated sint64 not_in = 7;
inline int SInt64Rules::not_in_size() const {
  return not_in_.size();
}
inline void SInt64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int64 SInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.not_in)
  return not_in_.Get(index);
}
inline void SInt64Rules::set_not_in(int index, ::google::protobuf::int64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.not_in)
}
inline void SInt64Rules::add_not_in(::google::protobuf::int64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SInt64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.SInt64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SInt64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// Fixed32Rules

// optional fixed32 const = 1;
inline bool Fixed32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fixed32Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fixed32Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fixed32Rules::clear_const_() {
  const__ = 0u;
  clear_has_const_();
}
inline ::google::protobuf::uint32 Fixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.const)
  return const__;
}
inline void Fixed32Rules::set_const_(::google::protobuf::uint32 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.const)
}

// optional fixed32 lt = 2;
inline bool Fixed32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fixed32Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Fixed32Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Fixed32Rules::clear_lt() {
  lt_ = 0u;
  clear_has_lt();
}
inline ::google::protobuf::uint32 Fixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.lt)
  return lt_;
}
inline void Fixed32Rules::set_lt(::google::protobuf::uint32 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.lt)
}

// optional fixed32 lte = 3;
inline bool Fixed32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fixed32Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Fixed32Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Fixed32Rules::clear_lte() {
  lte_ = 0u;
  clear_has_lte();
}
inline ::google::protobuf::uint32 Fixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.lte)
  return lte_;
}
inline void Fixed32Rules::set_lte(::google::protobuf::uint32 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.lte)
}

// optional fixed32 gt = 4;
inline bool Fixed32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fixed32Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Fixed32Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Fixed32Rules::clear_gt() {
  gt_ = 0u;
  clear_has_gt();
}
inline ::google::protobuf::uint32 Fixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.gt)
  return gt_;
}
inline void Fixed32Rules::set_gt(::google::protobuf::uint32 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.gt)
}

// optional fixed32 gte = 5;
inline bool Fixed32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fixed32Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Fixed32Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Fixed32Rules::clear_gte() {
  gte_ = 0u;
  clear_has_gte();
}
inline ::google::protobuf::uint32 Fixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.gte)
  return gte_;
}
inline void Fixed32Rules::set_gte(::google::protobuf::uint32 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.gte)
}

// repeated fixed32 in = 6;
inline int Fixed32Rules::in_size() const {
  return in_.size();
}
inline void Fixed32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint32 Fixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.in)
  return in_.Get(index);
}
inline void Fixed32Rules::set_in(int index, ::google::protobuf::uint32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.in)
}
inline void Fixed32Rules::add_in(::google::protobuf::uint32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Fixed32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.Fixed32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Fixed32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed32Rules.in)
  return &in_;
}

// repeated fixed32 not_in = 7;
inline int Fixed32Rules::not_in_size() const {
  return not_in_.size();
}
inline void Fixed32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint32 Fixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.not_in)
  return not_in_.Get(index);
}
inline void Fixed32Rules::set_not_in(int index, ::google::protobuf::uint32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.not_in)
}
inline void Fixed32Rules::add_not_in(::google::protobuf::uint32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Fixed32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.Fixed32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Fixed32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// Fixed64Rules

// optional fixed64 const = 1;
inline bool Fixed64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fixed64Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fixed64Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fixed64Rules::clear_const_() {
  const__ = GOOGLE_ULONGLONG(0);
  clear_has_const_();
}
inline ::google::protobuf::uint64 Fixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.const)
  return const__;
}
inline void Fixed64Rules::set_const_(::google::protobuf::uint64 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.const)
}

// optional fixed64 lt = 2;
inline bool Fixed64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fixed64Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Fixed64Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Fixed64Rules::clear_lt() {
  lt_ = GOOGLE_ULONGLONG(0);
  clear_has_lt();
}
inline ::google::protobuf::uint64 Fixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.lt)
  return lt_;
}
inline void Fixed64Rules::set_lt(::google::protobuf::uint64 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.lt)
}

// optional fixed64 lte = 3;
inline bool Fixed64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fixed64Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Fixed64Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Fixed64Rules::clear_lte() {
  lte_ = GOOGLE_ULONGLONG(0);
  clear_has_lte();
}
inline ::google::protobuf::uint64 Fixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.lte)
  return lte_;
}
inline void Fixed64Rules::set_lte(::google::protobuf::uint64 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.lte)
}

// optional fixed64 gt = 4;
inline bool Fixed64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fixed64Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Fixed64Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Fixed64Rules::clear_gt() {
  gt_ = GOOGLE_ULONGLONG(0);
  clear_has_gt();
}
inline ::google::protobuf::uint64 Fixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.gt)
  return gt_;
}
inline void Fixed64Rules::set_gt(::google::protobuf::uint64 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.gt)
}

// optional fixed64 gte = 5;
inline bool Fixed64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fixed64Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Fixed64Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Fixed64Rules::clear_gte() {
  gte_ = GOOGLE_ULONGLONG(0);
  clear_has_gte();
}
inline ::google::protobuf::uint64 Fixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.gte)
  return gte_;
}
inline void Fixed64Rules::set_gte(::google::protobuf::uint64 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.gte)
}

// repeated fixed64 in = 6;
inline int Fixed64Rules::in_size() const {
  return in_.size();
}
inline void Fixed64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint64 Fixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.in)
  return in_.Get(index);
}
inline void Fixed64Rules::set_in(int index, ::google::protobuf::uint64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.in)
}
inline void Fixed64Rules::add_in(::google::protobuf::uint64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Fixed64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.Fixed64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Fixed64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed64Rules.in)
  return &in_;
}

// repeated fixed64 not_in = 7;
inline int Fixed64Rules::not_in_size() const {
  return not_in_.size();
}
inline void Fixed64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint64 Fixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.not_in)
  return not_in_.Get(index);
}
inline void Fixed64Rules::set_not_in(int index, ::google::protobuf::uint64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.not_in)
}
inline void Fixed64Rules::add_not_in(::google::protobuf::uint64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Fixed64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.Fixed64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Fixed64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// SFixed32Rules

// optional sfixed32 const = 1;
inline bool SFixed32Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SFixed32Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SFixed32Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SFixed32Rules::clear_const_() {
  const__ = 0;
  clear_has_const_();
}
inline ::google::protobuf::int32 SFixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.const)
  return const__;
}
inline void SFixed32Rules::set_const_(::google::protobuf::int32 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.const)
}

// optional sfixed32 lt = 2;
inline bool SFixed32Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SFixed32Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SFixed32Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SFixed32Rules::clear_lt() {
  lt_ = 0;
  clear_has_lt();
}
inline ::google::protobuf::int32 SFixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.lt)
  return lt_;
}
inline void SFixed32Rules::set_lt(::google::protobuf::int32 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.lt)
}

// optional sfixed32 lte = 3;
inline bool SFixed32Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SFixed32Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SFixed32Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SFixed32Rules::clear_lte() {
  lte_ = 0;
  clear_has_lte();
}
inline ::google::protobuf::int32 SFixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.lte)
  return lte_;
}
inline void SFixed32Rules::set_lte(::google::protobuf::int32 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.lte)
}

// optional sfixed32 gt = 4;
inline bool SFixed32Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SFixed32Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SFixed32Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SFixed32Rules::clear_gt() {
  gt_ = 0;
  clear_has_gt();
}
inline ::google::protobuf::int32 SFixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.gt)
  return gt_;
}
inline void SFixed32Rules::set_gt(::google::protobuf::int32 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.gt)
}

// optional sfixed32 gte = 5;
inline bool SFixed32Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SFixed32Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SFixed32Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SFixed32Rules::clear_gte() {
  gte_ = 0;
  clear_has_gte();
}
inline ::google::protobuf::int32 SFixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.gte)
  return gte_;
}
inline void SFixed32Rules::set_gte(::google::protobuf::int32 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.gte)
}

// repeated sfixed32 in = 6;
inline int SFixed32Rules::in_size() const {
  return in_.size();
}
inline void SFixed32Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 SFixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.in)
  return in_.Get(index);
}
inline void SFixed32Rules::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.in)
}
inline void SFixed32Rules::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SFixed32Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.SFixed32Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SFixed32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed32Rules.in)
  return &in_;
}

// repeated sfixed32 not_in = 7;
inline int SFixed32Rules::not_in_size() const {
  return not_in_.size();
}
inline void SFixed32Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 SFixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.not_in)
  return not_in_.Get(index);
}
inline void SFixed32Rules::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.not_in)
}
inline void SFixed32Rules::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SFixed32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.SFixed32Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SFixed32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed32Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// SFixed64Rules

// optional sfixed64 const = 1;
inline bool SFixed64Rules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SFixed64Rules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SFixed64Rules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SFixed64Rules::clear_const_() {
  const__ = GOOGLE_LONGLONG(0);
  clear_has_const_();
}
inline ::google::protobuf::int64 SFixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.const)
  return const__;
}
inline void SFixed64Rules::set_const_(::google::protobuf::int64 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.const)
}

// optional sfixed64 lt = 2;
inline bool SFixed64Rules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SFixed64Rules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SFixed64Rules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SFixed64Rules::clear_lt() {
  lt_ = GOOGLE_LONGLONG(0);
  clear_has_lt();
}
inline ::google::protobuf::int64 SFixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.lt)
  return lt_;
}
inline void SFixed64Rules::set_lt(::google::protobuf::int64 value) {
  set_has_lt();
  lt_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.lt)
}

// optional sfixed64 lte = 3;
inline bool SFixed64Rules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SFixed64Rules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SFixed64Rules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SFixed64Rules::clear_lte() {
  lte_ = GOOGLE_LONGLONG(0);
  clear_has_lte();
}
inline ::google::protobuf::int64 SFixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.lte)
  return lte_;
}
inline void SFixed64Rules::set_lte(::google::protobuf::int64 value) {
  set_has_lte();
  lte_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.lte)
}

// optional sfixed64 gt = 4;
inline bool SFixed64Rules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SFixed64Rules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SFixed64Rules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SFixed64Rules::clear_gt() {
  gt_ = GOOGLE_LONGLONG(0);
  clear_has_gt();
}
inline ::google::protobuf::int64 SFixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.gt)
  return gt_;
}
inline void SFixed64Rules::set_gt(::google::protobuf::int64 value) {
  set_has_gt();
  gt_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.gt)
}

// optional sfixed64 gte = 5;
inline bool SFixed64Rules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SFixed64Rules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SFixed64Rules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SFixed64Rules::clear_gte() {
  gte_ = GOOGLE_LONGLONG(0);
  clear_has_gte();
}
inline ::google::protobuf::int64 SFixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.gte)
  return gte_;
}
inline void SFixed64Rules::set_gte(::google::protobuf::int64 value) {
  set_has_gte();
  gte_ = value;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.gte)
}

// repeated sfixed64 in = 6;
inline int SFixed64Rules::in_size() const {
  return in_.size();
}
inline void SFixed64Rules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int64 SFixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.in)
  return in_.Get(index);
}
inline void SFixed64Rules::set_in(int index, ::google::protobuf::int64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.in)
}
inline void SFixed64Rules::add_in(::google::protobuf::int64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SFixed64Rules::in() const {
  // @@protoc_insertion_point(field_list:validate.SFixed64Rules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SFixed64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed64Rules.in)
  return &in_;
}

// repeated sfixed64 not_in = 7;
inline int SFixed64Rules::not_in_size() const {
  return not_in_.size();
}
inline void SFixed64Rules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int64 SFixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.not_in)
  return not_in_.Get(index);
}
inline void SFixed64Rules::set_not_in(int index, ::google::protobuf::int64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.not_in)
}
inline void SFixed64Rules::add_not_in(::google::protobuf::int64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SFixed64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.SFixed64Rules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SFixed64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed64Rules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// BoolRules

// optional bool const = 1;
inline bool BoolRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoolRules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoolRules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoolRules::clear_const_() {
  const__ = false;
  clear_has_const_();
}
inline bool BoolRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.BoolRules.const)
  return const__;
}
inline void BoolRules::set_const_(bool value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.BoolRules.const)
}

// -------------------------------------------------------------------

// StringRules

// optional string const = 1;
inline bool StringRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringRules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringRules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringRules::clear_const_() {
  const__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_const_();
}
inline const ::std::string& StringRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.const)
  return const__.GetNoArena();
}
inline void StringRules::set_const_(const ::std::string& value) {
  set_has_const_();
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.const)
}
#if LANG_CXX11
inline void StringRules::set_const_(::std::string&& value) {
  set_has_const_();
  const__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.const)
}
#endif
inline void StringRules::set_const_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_const_();
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.const)
}
inline void StringRules::set_const_(const char* value, size_t size) {
  set_has_const_();
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.const)
}
inline ::std::string* StringRules::mutable_const_() {
  set_has_const_();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.const)
  return const__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_const_() {
  // @@protoc_insertion_point(field_release:validate.StringRules.const)
  clear_has_const_();
  return const__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_const_(::std::string* const_) {
  if (const_ != NULL) {
    set_has_const_();
  } else {
    clear_has_const_();
  }
  const__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), const_);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.const)
}

// optional uint64 len = 19;
inline bool StringRules::has_len() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StringRules::set_has_len() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StringRules::clear_has_len() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StringRules::clear_len() {
  len_ = GOOGLE_ULONGLONG(0);
  clear_has_len();
}
inline ::google::protobuf::uint64 StringRules::len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.len)
  return len_;
}
inline void StringRules::set_len(::google::protobuf::uint64 value) {
  set_has_len();
  len_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.len)
}

// optional uint64 min_len = 2;
inline bool StringRules::has_min_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StringRules::set_has_min_len() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StringRules::clear_has_min_len() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StringRules::clear_min_len() {
  min_len_ = GOOGLE_ULONGLONG(0);
  clear_has_min_len();
}
inline ::google::protobuf::uint64 StringRules::min_len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.min_len)
  return min_len_;
}
inline void StringRules::set_min_len(::google::protobuf::uint64 value) {
  set_has_min_len();
  min_len_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.min_len)
}

// optional uint64 max_len = 3;
inline bool StringRules::has_max_len() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StringRules::set_has_max_len() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StringRules::clear_has_max_len() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StringRules::clear_max_len() {
  max_len_ = GOOGLE_ULONGLONG(0);
  clear_has_max_len();
}
inline ::google::protobuf::uint64 StringRules::max_len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.max_len)
  return max_len_;
}
inline void StringRules::set_max_len(::google::protobuf::uint64 value) {
  set_has_max_len();
  max_len_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.max_len)
}

// optional uint64 len_bytes = 20;
inline bool StringRules::has_len_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StringRules::set_has_len_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StringRules::clear_has_len_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StringRules::clear_len_bytes() {
  len_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_len_bytes();
}
inline ::google::protobuf::uint64 StringRules::len_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.len_bytes)
  return len_bytes_;
}
inline void StringRules::set_len_bytes(::google::protobuf::uint64 value) {
  set_has_len_bytes();
  len_bytes_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.len_bytes)
}

// optional uint64 min_bytes = 4;
inline bool StringRules::has_min_bytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StringRules::set_has_min_bytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StringRules::clear_has_min_bytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StringRules::clear_min_bytes() {
  min_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_min_bytes();
}
inline ::google::protobuf::uint64 StringRules::min_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.min_bytes)
  return min_bytes_;
}
inline void StringRules::set_min_bytes(::google::protobuf::uint64 value) {
  set_has_min_bytes();
  min_bytes_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.min_bytes)
}

// optional uint64 max_bytes = 5;
inline bool StringRules::has_max_bytes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StringRules::set_has_max_bytes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StringRules::clear_has_max_bytes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StringRules::clear_max_bytes() {
  max_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_bytes();
}
inline ::google::protobuf::uint64 StringRules::max_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.max_bytes)
  return max_bytes_;
}
inline void StringRules::set_max_bytes(::google::protobuf::uint64 value) {
  set_has_max_bytes();
  max_bytes_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.max_bytes)
}

// optional string pattern = 6;
inline bool StringRules::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringRules::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringRules::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringRules::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pattern();
}
inline const ::std::string& StringRules::pattern() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.pattern)
  return pattern_.GetNoArena();
}
inline void StringRules::set_pattern(const ::std::string& value) {
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.pattern)
}
#if LANG_CXX11
inline void StringRules::set_pattern(::std::string&& value) {
  set_has_pattern();
  pattern_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.pattern)
}
#endif
inline void StringRules::set_pattern(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.pattern)
}
inline void StringRules::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.pattern)
}
inline ::std::string* StringRules::mutable_pattern() {
  set_has_pattern();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_pattern() {
  // @@protoc_insertion_point(field_release:validate.StringRules.pattern)
  clear_has_pattern();
  return pattern_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_pattern(::std::string* pattern) {
  if (pattern != NULL) {
    set_has_pattern();
  } else {
    clear_has_pattern();
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.pattern)
}

// optional string prefix = 7;
inline bool StringRules::has_prefix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StringRules::set_has_prefix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StringRules::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StringRules::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prefix();
}
inline const ::std::string& StringRules::prefix() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.prefix)
  return prefix_.GetNoArena();
}
inline void StringRules::set_prefix(const ::std::string& value) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.prefix)
}
#if LANG_CXX11
inline void StringRules::set_prefix(::std::string&& value) {
  set_has_prefix();
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.prefix)
}
#endif
inline void StringRules::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.prefix)
}
inline void StringRules::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.prefix)
}
inline ::std::string* StringRules::mutable_prefix() {
  set_has_prefix();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_prefix() {
  // @@protoc_insertion_point(field_release:validate.StringRules.prefix)
  clear_has_prefix();
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    set_has_prefix();
  } else {
    clear_has_prefix();
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.prefix)
}

// optional string suffix = 8;
inline bool StringRules::has_suffix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StringRules::set_has_suffix() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StringRules::clear_has_suffix() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StringRules::clear_suffix() {
  suffix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_suffix();
}
inline const ::std::string& StringRules::suffix() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.suffix)
  return suffix_.GetNoArena();
}
inline void StringRules::set_suffix(const ::std::string& value) {
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.suffix)
}
#if LANG_CXX11
inline void StringRules::set_suffix(::std::string&& value) {
  set_has_suffix();
  suffix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.suffix)
}
#endif
inline void StringRules::set_suffix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.suffix)
}
inline void StringRules::set_suffix(const char* value, size_t size) {
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.suffix)
}
inline ::std::string* StringRules::mutable_suffix() {
  set_has_suffix();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.suffix)
  return suffix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_suffix() {
  // @@protoc_insertion_point(field_release:validate.StringRules.suffix)
  clear_has_suffix();
  return suffix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_suffix(::std::string* suffix) {
  if (suffix != NULL) {
    set_has_suffix();
  } else {
    clear_has_suffix();
  }
  suffix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suffix);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.suffix)
}

// optional string contains = 9;
inline bool StringRules::has_contains() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StringRules::set_has_contains() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StringRules::clear_has_contains() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StringRules::clear_contains() {
  contains_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contains();
}
inline const ::std::string& StringRules::contains() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.contains)
  return contains_.GetNoArena();
}
inline void StringRules::set_contains(const ::std::string& value) {
  set_has_contains();
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.StringRules.contains)
}
#if LANG_CXX11
inline void StringRules::set_contains(::std::string&& value) {
  set_has_contains();
  contains_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.StringRules.contains)
}
#endif
inline void StringRules::set_contains(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_contains();
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.StringRules.contains)
}
inline void StringRules::set_contains(const char* value, size_t size) {
  set_has_contains();
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.contains)
}
inline ::std::string* StringRules::mutable_contains() {
  set_has_contains();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.contains)
  return contains_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRules::release_contains() {
  // @@protoc_insertion_point(field_release:validate.StringRules.contains)
  clear_has_contains();
  return contains_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRules::set_allocated_contains(::std::string* contains) {
  if (contains != NULL) {
    set_has_contains();
  } else {
    clear_has_contains();
  }
  contains_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contains);
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.contains)
}

// repeated string in = 10;
inline int StringRules::in_size() const {
  return in_.size();
}
inline void StringRules::clear_in() {
  in_.Clear();
}
inline const ::std::string& StringRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.StringRules.in)
  return in_.Get(index);
}
inline ::std::string* StringRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.StringRules.in)
  return in_.Mutable(index);
}
inline void StringRules::set_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.StringRules.in)
  in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringRules::set_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.StringRules.in)
  in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringRules::set_in(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.StringRules.in)
}
inline void StringRules::set_in(int index, const char* value, size_t size) {
  in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.in)
}
inline ::std::string* StringRules::add_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.StringRules.in)
  return in_.Add();
}
inline void StringRules::add_in(const ::std::string& value) {
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.StringRules.in)
}
#if LANG_CXX11
inline void StringRules::add_in(::std::string&& value) {
  in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.StringRules.in)
}
#endif
inline void StringRules::add_in(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.StringRules.in)
}
inline void StringRules::add_in(const char* value, size_t size) {
  in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.StringRules.in)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringRules::in() const {
  // @@protoc_insertion_point(field_list:validate.StringRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.StringRules.in)
  return &in_;
}

// repeated string not_in = 11;
inline int StringRules::not_in_size() const {
  return not_in_.size();
}
inline void StringRules::clear_not_in() {
  not_in_.Clear();
}
inline const ::std::string& StringRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.StringRules.not_in)
  return not_in_.Get(index);
}
inline ::std::string* StringRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.StringRules.not_in)
  return not_in_.Mutable(index);
}
inline void StringRules::set_not_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.StringRules.not_in)
  not_in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringRules::set_not_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.StringRules.not_in)
  not_in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringRules::set_not_in(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  not_in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, const char* value, size_t size) {
  not_in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.StringRules.not_in)
}
inline ::std::string* StringRules::add_not_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.StringRules.not_in)
  return not_in_.Add();
}
inline void StringRules::add_not_in(const ::std::string& value) {
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.StringRules.not_in)
}
#if LANG_CXX11
inline void StringRules::add_not_in(::std::string&& value) {
  not_in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.StringRules.not_in)
}
#endif
inline void StringRules::add_not_in(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.StringRules.not_in)
}
inline void StringRules::add_not_in(const char* value, size_t size) {
  not_in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.StringRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.StringRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.StringRules.not_in)
  return &not_in_;
}

// optional bool email = 12;
inline bool StringRules::has_email() const {
  return well_known_case() == kEmail;
}
inline void StringRules::set_has_email() {
  _oneof_case_[0] = kEmail;
}
inline void StringRules::clear_email() {
  if (has_email()) {
    well_known_.email_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::email() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.email)
  if (has_email()) {
    return well_known_.email_;
  }
  return false;
}
inline void StringRules::set_email(bool value) {
  if (!has_email()) {
    clear_well_known();
    set_has_email();
  }
  well_known_.email_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.email)
}

// optional bool hostname = 13;
inline bool StringRules::has_hostname() const {
  return well_known_case() == kHostname;
}
inline void StringRules::set_has_hostname() {
  _oneof_case_[0] = kHostname;
}
inline void StringRules::clear_hostname() {
  if (has_hostname()) {
    well_known_.hostname_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::hostname() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.hostname)
  if (has_hostname()) {
    return well_known_.hostname_;
  }
  return false;
}
inline void StringRules::set_hostname(bool value) {
  if (!has_hostname()) {
    clear_well_known();
    set_has_hostname();
  }
  well_known_.hostname_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.hostname)
}

// optional bool ip = 14;
inline bool StringRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void StringRules::set_has_ip() {
  _oneof_case_[0] = kIp;
}
inline void StringRules::clear_ip() {
  if (has_ip()) {
    well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ip() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ip)
  if (has_ip()) {
    return well_known_.ip_;
  }
  return false;
}
inline void StringRules::set_ip(bool value) {
  if (!has_ip()) {
    clear_well_known();
    set_has_ip();
  }
  well_known_.ip_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ip)
}

// optional bool ipv4 = 15;
inline bool StringRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void StringRules::set_has_ipv4() {
  _oneof_case_[0] = kIpv4;
}
inline void StringRules::clear_ipv4() {
  if (has_ipv4()) {
    well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv4() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ipv4)
  if (has_ipv4()) {
    return well_known_.ipv4_;
  }
  return false;
}
inline void StringRules::set_ipv4(bool value) {
  if (!has_ipv4()) {
    clear_well_known();
    set_has_ipv4();
  }
  well_known_.ipv4_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ipv4)
}

// optional bool ipv6 = 16;
inline bool StringRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void StringRules::set_has_ipv6() {
  _oneof_case_[0] = kIpv6;
}
inline void StringRules::clear_ipv6() {
  if (has_ipv6()) {
    well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv6() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ipv6)
  if (has_ipv6()) {
    return well_known_.ipv6_;
  }
  return false;
}
inline void StringRules::set_ipv6(bool value) {
  if (!has_ipv6()) {
    clear_well_known();
    set_has_ipv6();
  }
  well_known_.ipv6_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ipv6)
}

// optional bool uri = 17;
inline bool StringRules::has_uri() const {
  return well_known_case() == kUri;
}
inline void StringRules::set_has_uri() {
  _oneof_case_[0] = kUri;
}
inline void StringRules::clear_uri() {
  if (has_uri()) {
    well_known_.uri_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.uri)
  if (has_uri()) {
    return well_known_.uri_;
  }
  return false;
}
inline void StringRules::set_uri(bool value) {
  if (!has_uri()) {
    clear_well_known();
    set_has_uri();
  }
  well_known_.uri_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.uri)
}

// optional bool uri_ref = 18;
inline bool StringRules::has_uri_ref() const {
  return well_known_case() == kUriRef;
}
inline void StringRules::set_has_uri_ref() {
  _oneof_case_[0] = kUriRef;
}
inline void StringRules::clear_uri_ref() {
  if (has_uri_ref()) {
    well_known_.uri_ref_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri_ref() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.uri_ref)
  if (has_uri_ref()) {
    return well_known_.uri_ref_;
  }
  return false;
}
inline void StringRules::set_uri_ref(bool value) {
  if (!has_uri_ref()) {
    clear_well_known();
    set_has_uri_ref();
  }
  well_known_.uri_ref_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.uri_ref)
}

inline bool StringRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void StringRules::clear_has_well_known() {
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline StringRules::WellKnownCase StringRules::well_known_case() const {
  return StringRules::WellKnownCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BytesRules

// optional bytes const = 1;
inline bool BytesRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytesRules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytesRules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytesRules::clear_const_() {
  const__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_const_();
}
inline const ::std::string& BytesRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.const)
  return const__.GetNoArena();
}
inline void BytesRules::set_const_(const ::std::string& value) {
  set_has_const_();
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.const)
}
#if LANG_CXX11
inline void BytesRules::set_const_(::std::string&& value) {
  set_has_const_();
  const__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.const)
}
#endif
inline void BytesRules::set_const_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_const_();
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.const)
}
inline void BytesRules::set_const_(const void* value, size_t size) {
  set_has_const_();
  const__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.const)
}
inline ::std::string* BytesRules::mutable_const_() {
  set_has_const_();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.const)
  return const__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_const_() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.const)
  clear_has_const_();
  return const__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_const_(::std::string* const_) {
  if (const_ != NULL) {
    set_has_const_();
  } else {
    clear_has_const_();
  }
  const__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), const_);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.const)
}

// optional uint64 len = 13;
inline bool BytesRules::has_len() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BytesRules::set_has_len() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BytesRules::clear_has_len() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BytesRules::clear_len() {
  len_ = GOOGLE_ULONGLONG(0);
  clear_has_len();
}
inline ::google::protobuf::uint64 BytesRules::len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.len)
  return len_;
}
inline void BytesRules::set_len(::google::protobuf::uint64 value) {
  set_has_len();
  len_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.len)
}

// optional uint64 min_len = 2;
inline bool BytesRules::has_min_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BytesRules::set_has_min_len() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BytesRules::clear_has_min_len() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BytesRules::clear_min_len() {
  min_len_ = GOOGLE_ULONGLONG(0);
  clear_has_min_len();
}
inline ::google::protobuf::uint64 BytesRules::min_len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.min_len)
  return min_len_;
}
inline void BytesRules::set_min_len(::google::protobuf::uint64 value) {
  set_has_min_len();
  min_len_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.min_len)
}

// optional uint64 max_len = 3;
inline bool BytesRules::has_max_len() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BytesRules::set_has_max_len() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BytesRules::clear_has_max_len() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BytesRules::clear_max_len() {
  max_len_ = GOOGLE_ULONGLONG(0);
  clear_has_max_len();
}
inline ::google::protobuf::uint64 BytesRules::max_len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.max_len)
  return max_len_;
}
inline void BytesRules::set_max_len(::google::protobuf::uint64 value) {
  set_has_max_len();
  max_len_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.max_len)
}

// optional string pattern = 4;
inline bool BytesRules::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytesRules::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytesRules::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytesRules::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pattern();
}
inline const ::std::string& BytesRules::pattern() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.pattern)
  return pattern_.GetNoArena();
}
inline void BytesRules::set_pattern(const ::std::string& value) {
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.pattern)
}
#if LANG_CXX11
inline void BytesRules::set_pattern(::std::string&& value) {
  set_has_pattern();
  pattern_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.pattern)
}
#endif
inline void BytesRules::set_pattern(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.pattern)
}
inline void BytesRules::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.pattern)
}
inline ::std::string* BytesRules::mutable_pattern() {
  set_has_pattern();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_pattern() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.pattern)
  clear_has_pattern();
  return pattern_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_pattern(::std::string* pattern) {
  if (pattern != NULL) {
    set_has_pattern();
  } else {
    clear_has_pattern();
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.pattern)
}

// optional bytes prefix = 5;
inline bool BytesRules::has_prefix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytesRules::set_has_prefix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytesRules::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytesRules::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prefix();
}
inline const ::std::string& BytesRules::prefix() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.prefix)
  return prefix_.GetNoArena();
}
inline void BytesRules::set_prefix(const ::std::string& value) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.prefix)
}
#if LANG_CXX11
inline void BytesRules::set_prefix(::std::string&& value) {
  set_has_prefix();
  prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.prefix)
}
#endif
inline void BytesRules::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.prefix)
}
inline void BytesRules::set_prefix(const void* value, size_t size) {
  set_has_prefix();
  prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.prefix)
}
inline ::std::string* BytesRules::mutable_prefix() {
  set_has_prefix();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.prefix)
  return prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_prefix() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.prefix)
  clear_has_prefix();
  return prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_prefix(::std::string* prefix) {
  if (prefix != NULL) {
    set_has_prefix();
  } else {
    clear_has_prefix();
  }
  prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.prefix)
}

// optional bytes suffix = 6;
inline bool BytesRules::has_suffix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BytesRules::set_has_suffix() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BytesRules::clear_has_suffix() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BytesRules::clear_suffix() {
  suffix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_suffix();
}
inline const ::std::string& BytesRules::suffix() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.suffix)
  return suffix_.GetNoArena();
}
inline void BytesRules::set_suffix(const ::std::string& value) {
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.suffix)
}
#if LANG_CXX11
inline void BytesRules::set_suffix(::std::string&& value) {
  set_has_suffix();
  suffix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.suffix)
}
#endif
inline void BytesRules::set_suffix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.suffix)
}
inline void BytesRules::set_suffix(const void* value, size_t size) {
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.suffix)
}
inline ::std::string* BytesRules::mutable_suffix() {
  set_has_suffix();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.suffix)
  return suffix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_suffix() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.suffix)
  clear_has_suffix();
  return suffix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_suffix(::std::string* suffix) {
  if (suffix != NULL) {
    set_has_suffix();
  } else {
    clear_has_suffix();
  }
  suffix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suffix);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.suffix)
}

// optional bytes contains = 7;
inline bool BytesRules::has_contains() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BytesRules::set_has_contains() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BytesRules::clear_has_contains() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BytesRules::clear_contains() {
  contains_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contains();
}
inline const ::std::string& BytesRules::contains() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.contains)
  return contains_.GetNoArena();
}
inline void BytesRules::set_contains(const ::std::string& value) {
  set_has_contains();
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validate.BytesRules.contains)
}
#if LANG_CXX11
inline void BytesRules::set_contains(::std::string&& value) {
  set_has_contains();
  contains_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validate.BytesRules.contains)
}
#endif
inline void BytesRules::set_contains(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_contains();
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.contains)
}
inline void BytesRules::set_contains(const void* value, size_t size) {
  set_has_contains();
  contains_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.contains)
}
inline ::std::string* BytesRules::mutable_contains() {
  set_has_contains();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.contains)
  return contains_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesRules::release_contains() {
  // @@protoc_insertion_point(field_release:validate.BytesRules.contains)
  clear_has_contains();
  return contains_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesRules::set_allocated_contains(::std::string* contains) {
  if (contains != NULL) {
    set_has_contains();
  } else {
    clear_has_contains();
  }
  contains_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contains);
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.contains)
}

// repeated bytes in = 8;
inline int BytesRules::in_size() const {
  return in_.size();
}
inline void BytesRules::clear_in() {
  in_.Clear();
}
inline const ::std::string& BytesRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.in)
  return in_.Get(index);
}
inline ::std::string* BytesRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.in)
  return in_.Mutable(index);
}
inline void BytesRules::set_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.BytesRules.in)
  in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BytesRules::set_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.BytesRules.in)
  in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BytesRules::set_in(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, const void* value, size_t size) {
  in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.in)
}
inline ::std::string* BytesRules::add_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.BytesRules.in)
  return in_.Add();
}
inline void BytesRules::add_in(const ::std::string& value) {
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.BytesRules.in)
}
#if LANG_CXX11
inline void BytesRules::add_in(::std::string&& value) {
  in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.BytesRules.in)
}
#endif
inline void BytesRules::add_in(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.BytesRules.in)
}
inline void BytesRules::add_in(const void* value, size_t size) {
  in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.BytesRules.in)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BytesRules::in() const {
  // @@protoc_insertion_point(field_list:validate.BytesRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BytesRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.BytesRules.in)
  return &in_;
}

// repeated bytes not_in = 9;
inline int BytesRules::not_in_size() const {
  return not_in_.size();
}
inline void BytesRules::clear_not_in() {
  not_in_.Clear();
}
inline const ::std::string& BytesRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.not_in)
  return not_in_.Get(index);
}
inline ::std::string* BytesRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.not_in)
  return not_in_.Mutable(index);
}
inline void BytesRules::set_not_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.BytesRules.not_in)
  not_in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BytesRules::set_not_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.BytesRules.not_in)
  not_in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BytesRules::set_not_in(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  not_in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, const void* value, size_t size) {
  not_in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.BytesRules.not_in)
}
inline ::std::string* BytesRules::add_not_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.BytesRules.not_in)
  return not_in_.Add();
}
inline void BytesRules::add_not_in(const ::std::string& value) {
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.BytesRules.not_in)
}
#if LANG_CXX11
inline void BytesRules::add_not_in(::std::string&& value) {
  not_in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.BytesRules.not_in)
}
#endif
inline void BytesRules::add_not_in(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(const void* value, size_t size) {
  not_in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.BytesRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BytesRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.BytesRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BytesRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.BytesRules.not_in)
  return &not_in_;
}

// optional bool ip = 10;
inline bool BytesRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void BytesRules::set_has_ip() {
  _oneof_case_[0] = kIp;
}
inline void BytesRules::clear_ip() {
  if (has_ip()) {
    well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ip() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ip)
  if (has_ip()) {
    return well_known_.ip_;
  }
  return false;
}
inline void BytesRules::set_ip(bool value) {
  if (!has_ip()) {
    clear_well_known();
    set_has_ip();
  }
  well_known_.ip_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ip)
}

// optional bool ipv4 = 11;
inline bool BytesRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void BytesRules::set_has_ipv4() {
  _oneof_case_[0] = kIpv4;
}
inline void BytesRules::clear_ipv4() {
  if (has_ipv4()) {
    well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv4() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ipv4)
  if (has_ipv4()) {
    return well_known_.ipv4_;
  }
  return false;
}
inline void BytesRules::set_ipv4(bool value) {
  if (!has_ipv4()) {
    clear_well_known();
    set_has_ipv4();
  }
  well_known_.ipv4_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ipv4)
}

// optional bool ipv6 = 12;
inline bool BytesRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void BytesRules::set_has_ipv6() {
  _oneof_case_[0] = kIpv6;
}
inline void BytesRules::clear_ipv6() {
  if (has_ipv6()) {
    well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv6() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ipv6)
  if (has_ipv6()) {
    return well_known_.ipv6_;
  }
  return false;
}
inline void BytesRules::set_ipv6(bool value) {
  if (!has_ipv6()) {
    clear_well_known();
    set_has_ipv6();
  }
  well_known_.ipv6_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ipv6)
}

inline bool BytesRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void BytesRules::clear_has_well_known() {
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline BytesRules::WellKnownCase BytesRules::well_known_case() const {
  return BytesRules::WellKnownCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EnumRules

// optional int32 const = 1;
inline bool EnumRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumRules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumRules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumRules::clear_const_() {
  const__ = 0;
  clear_has_const_();
}
inline ::google::protobuf::int32 EnumRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.const)
  return const__;
}
inline void EnumRules::set_const_(::google::protobuf::int32 value) {
  set_has_const_();
  const__ = value;
  // @@protoc_insertion_point(field_set:validate.EnumRules.const)
}

// optional bool defined_only = 2;
inline bool EnumRules::has_defined_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnumRules::set_has_defined_only() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnumRules::clear_has_defined_only() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnumRules::clear_defined_only() {
  defined_only_ = false;
  clear_has_defined_only();
}
inline bool EnumRules::defined_only() const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.defined_only)
  return defined_only_;
}
inline void EnumRules::set_defined_only(bool value) {
  set_has_defined_only();
  defined_only_ = value;
  // @@protoc_insertion_point(field_set:validate.EnumRules.defined_only)
}

// repeated int32 in = 3;
inline int EnumRules::in_size() const {
  return in_.size();
}
inline void EnumRules::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 EnumRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.in)
  return in_.Get(index);
}
inline void EnumRules::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.EnumRules.in)
}
inline void EnumRules::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.EnumRules.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EnumRules::in() const {
  // @@protoc_insertion_point(field_list:validate.EnumRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EnumRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.EnumRules.in)
  return &in_;
}

// repeated int32 not_in = 4;
inline int EnumRules::not_in_size() const {
  return not_in_.size();
}
inline void EnumRules::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 EnumRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.not_in)
  return not_in_.Get(index);
}
inline void EnumRules::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validate.EnumRules.not_in)
}
inline void EnumRules::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validate.EnumRules.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EnumRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.EnumRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EnumRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.EnumRules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// MessageRules

// optional bool skip = 1;
inline bool MessageRules::has_skip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageRules::set_has_skip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageRules::clear_has_skip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageRules::clear_skip() {
  skip_ = false;
  clear_has_skip();
}
inline bool MessageRules::skip() const {
  // @@protoc_insertion_point(field_get:validate.MessageRules.skip)
  return skip_;
}
inline void MessageRules::set_skip(bool value) {
  set_has_skip();
  skip_ = value;
  // @@protoc_insertion_point(field_set:validate.MessageRules.skip)
}

// optional bool required = 2;
inline bool MessageRules::has_required() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageRules::set_has_required() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageRules::clear_has_required() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageRules::clear_required() {
  required_ = false;
  clear_has_required();
}
inline bool MessageRules::required() const {
  // @@protoc_insertion_point(field_get:validate.MessageRules.required)
  return required_;
}
inline void MessageRules::set_required(bool value) {
  set_has_required();
  required_ = value;
  // @@protoc_insertion_point(field_set:validate.MessageRules.required)
}

// -------------------------------------------------------------------

// RepeatedRules

// optional uint64 min_items = 1;
inline bool RepeatedRules::has_min_items() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RepeatedRules::set_has_min_items() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RepeatedRules::clear_has_min_items() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RepeatedRules::clear_min_items() {
  min_items_ = GOOGLE_ULONGLONG(0);
  clear_has_min_items();
}
inline ::google::protobuf::uint64 RepeatedRules::min_items() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.min_items)
  return min_items_;
}
inline void RepeatedRules::set_min_items(::google::protobuf::uint64 value) {
  set_has_min_items();
  min_items_ = value;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.min_items)
}

// optional uint64 max_items = 2;
inline bool RepeatedRules::has_max_items() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RepeatedRules::set_has_max_items() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RepeatedRules::clear_has_max_items() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RepeatedRules::clear_max_items() {
  max_items_ = GOOGLE_ULONGLONG(0);
  clear_has_max_items();
}
inline ::google::protobuf::uint64 RepeatedRules::max_items() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.max_items)
  return max_items_;
}
inline void RepeatedRules::set_max_items(::google::protobuf::uint64 value) {
  set_has_max_items();
  max_items_ = value;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.max_items)
}

// optional bool unique = 3;
inline bool RepeatedRules::has_unique() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RepeatedRules::set_has_unique() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RepeatedRules::clear_has_unique() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RepeatedRules::clear_unique() {
  unique_ = false;
  clear_has_unique();
}
inline bool RepeatedRules::unique() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.unique)
  return unique_;
}
inline void RepeatedRules::set_unique(bool value) {
  set_has_unique();
  unique_ = value;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.unique)
}

// optional .validate.FieldRules items = 4;
inline bool RepeatedRules::has_items() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RepeatedRules::set_has_items() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RepeatedRules::clear_has_items() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RepeatedRules::clear_items() {
  if (items_ != NULL) items_->::validate::FieldRules::Clear();
  clear_has_items();
}
inline const ::validate::FieldRules& RepeatedRules::items() const {
  const ::validate::FieldRules* p = items_;
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.items)
  return p != NULL ? *p : *reinterpret_cast<const ::validate::FieldRules*>(
      &::validate::_FieldRules_default_instance_);
}
inline ::validate::FieldRules* RepeatedRules::mutable_items() {
  set_has_items();
  if (items_ == NULL) {
    items_ = new ::validate::FieldRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.RepeatedRules.items)
  return items_;
}
inline ::validate::FieldRules* RepeatedRules::release_items() {
  // @@protoc_insertion_point(field_release:validate.RepeatedRules.items)
  clear_has_items();
  ::validate::FieldRules* temp = items_;
  items_ = NULL;
  return temp;
}
inline void RepeatedRules::set_allocated_items(::validate::FieldRules* items) {
  delete items_;
  items_ = items;
  if (items) {
    set_has_items();
  } else {
    clear_has_items();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.RepeatedRules.items)
}

// -------------------------------------------------------------------

// MapRules

// optional uint64 min_pairs = 1;
inline bool MapRules::has_min_pairs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapRules::set_has_min_pairs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapRules::clear_has_min_pairs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapRules::clear_min_pairs() {
  min_pairs_ = GOOGLE_ULONGLONG(0);
  clear_has_min_pairs();
}
inline ::google::protobuf::uint64 MapRules::min_pairs() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.min_pairs)
  return min_pairs_;
}
inline void MapRules::set_min_pairs(::google::protobuf::uint64 value) {
  set_has_min_pairs();
  min_pairs_ = value;
  // @@protoc_insertion_point(field_set:validate.MapRules.min_pairs)
}

// optional uint64 max_pairs = 2;
inline bool MapRules::has_max_pairs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapRules::set_has_max_pairs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapRules::clear_has_max_pairs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapRules::clear_max_pairs() {
  max_pairs_ = GOOGLE_ULONGLONG(0);
  clear_has_max_pairs();
}
inline ::google::protobuf::uint64 MapRules::max_pairs() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.max_pairs)
  return max_pairs_;
}
inline void MapRules::set_max_pairs(::google::protobuf::uint64 value) {
  set_has_max_pairs();
  max_pairs_ = value;
  // @@protoc_insertion_point(field_set:validate.MapRules.max_pairs)
}

// optional bool no_sparse = 3;
inline bool MapRules::has_no_sparse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapRules::set_has_no_sparse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapRules::clear_has_no_sparse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapRules::clear_no_sparse() {
  no_sparse_ = false;
  clear_has_no_sparse();
}
inline bool MapRules::no_sparse() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.no_sparse)
  return no_sparse_;
}
inline void MapRules::set_no_sparse(bool value) {
  set_has_no_sparse();
  no_sparse_ = value;
  // @@protoc_insertion_point(field_set:validate.MapRules.no_sparse)
}

// optional .validate.FieldRules keys = 4;
inline bool MapRules::has_keys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapRules::set_has_keys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapRules::clear_has_keys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapRules::clear_keys() {
  if (keys_ != NULL) keys_->::validate::FieldRules::Clear();
  clear_has_keys();
}
inline const ::validate::FieldRules& MapRules::keys() const {
  const ::validate::FieldRules* p = keys_;
  // @@protoc_insertion_point(field_get:validate.MapRules.keys)
  return p != NULL ? *p : *reinterpret_cast<const ::validate::FieldRules*>(
      &::validate::_FieldRules_default_instance_);
}
inline ::validate::FieldRules* MapRules::mutable_keys() {
  set_has_keys();
  if (keys_ == NULL) {
    keys_ = new ::validate::FieldRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.MapRules.keys)
  return keys_;
}
inline ::validate::FieldRules* MapRules::release_keys() {
  // @@protoc_insertion_point(field_release:validate.MapRules.keys)
  clear_has_keys();
  ::validate::FieldRules* temp = keys_;
  keys_ = NULL;
  return temp;
}
inline void MapRules::set_allocated_keys(::validate::FieldRules* keys) {
  delete keys_;
  keys_ = keys;
  if (keys) {
    set_has_keys();
  } else {
    clear_has_keys();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.MapRules.keys)
}

// optional .validate.FieldRules values = 5;
inline bool MapRules::has_values() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapRules::set_has_values() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapRules::clear_has_values() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapRules::clear_values() {
  if (values_ != NULL) values_->::validate::FieldRules::Clear();
  clear_has_values();
}
inline const ::validate::FieldRules& MapRules::values() const {
  const ::validate::FieldRules* p = values_;
  // @@protoc_insertion_point(field_get:validate.MapRules.values)
  return p != NULL ? *p : *reinterpret_cast<const ::validate::FieldRules*>(
      &::validate::_FieldRules_default_instance_);
}
inline ::validate::FieldRules* MapRules::mutable_values() {
  set_has_values();
  if (values_ == NULL) {
    values_ = new ::validate::FieldRules;
  }
  // @@protoc_insertion_point(field_mutable:validate.MapRules.values)
  return values_;
}
inline ::validate::FieldRules* MapRules::release_values() {
  // @@protoc_insertion_point(field_release:validate.MapRules.values)
  clear_has_values();
  ::validate::FieldRules* temp = values_;
  values_ = NULL;
  return temp;
}
inline void MapRules::set_allocated_values(::validate::FieldRules* values) {
  delete values_;
  values_ = values;
  if (values) {
    set_has_values();
  } else {
    clear_has_values();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.MapRules.values)
}

// -------------------------------------------------------------------

// AnyRules

// optional bool required = 1;
inline bool AnyRules::has_required() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnyRules::set_has_required() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnyRules::clear_has_required() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnyRules::clear_required() {
  required_ = false;
  clear_has_required();
}
inline bool AnyRules::required() const {
  // @@protoc_insertion_point(field_get:validate.AnyRules.required)
  return required_;
}
inline void AnyRules::set_required(bool value) {
  set_has_required();
  required_ = value;
  // @@protoc_insertion_point(field_set:validate.AnyRules.required)
}

// repeated string in = 2;
inline int AnyRules::in_size() const {
  return in_.size();
}
inline void AnyRules::clear_in() {
  in_.Clear();
}
inline const ::std::string& AnyRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.AnyRules.in)
  return in_.Get(index);
}
inline ::std::string* AnyRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.AnyRules.in)
  return in_.Mutable(index);
}
inline void AnyRules::set_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.AnyRules.in)
  in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AnyRules::set_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.AnyRules.in)
  in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AnyRules::set_in(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, const char* value, size_t size) {
  in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.AnyRules.in)
}
inline ::std::string* AnyRules::add_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.AnyRules.in)
  return in_.Add();
}
inline void AnyRules::add_in(const ::std::string& value) {
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.AnyRules.in)
}
#if LANG_CXX11
inline void AnyRules::add_in(::std::string&& value) {
  in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.AnyRules.in)
}
#endif
inline void AnyRules::add_in(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.AnyRules.in)
}
inline void AnyRules::add_in(const char* value, size_t size) {
  in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.AnyRules.in)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AnyRules::in() const {
  // @@protoc_insertion_point(field_list:validate.AnyRules.in)
  return in_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AnyRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.AnyRules.in)
  return &in_;
}

// repeated string not_in = 3;
inline int AnyRules::not_in_size() const {
  return not_in_.size();
}
inline void AnyRules::clear_not_in() {
  not_in_.Clear();
}
inline const ::std::string& AnyRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.AnyRules.not_in)
  return not_in_.Get(index);
}
inline ::std::string* AnyRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.AnyRules.not_in)
  return not_in_.Mutable(index);
}
inline void AnyRules::set_not_in(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:validate.AnyRules.not_in)
  not_in_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AnyRules::set_not_in(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:validate.AnyRules.not_in)
  not_in_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AnyRules::set_not_in(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  not_in_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, const char* value, size_t size) {
  not_in_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:validate.AnyRules.not_in)
}
inline ::std::string* AnyRules::add_not_in() {
  // @@protoc_insertion_point(field_add_mutable:validate.AnyRules.not_in)
  return not_in_.Add();
}
inline void AnyRules::add_not_in(const ::std::string& value) {
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:validate.AnyRules.not_in)
}
#if LANG_CXX11
inline void AnyRules::add_not_in(::std::string&& value) {
  not_in_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:validate.AnyRules.not_in)
}
#endif
inline void AnyRules::add_not_in(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  not_in_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(const char* value, size_t size) {
  not_in_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:validate.AnyRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AnyRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.AnyRules.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AnyRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.AnyRules.not_in)
  return &not_in_;
}

// -------------------------------------------------------------------

// DurationRules

// optional bool required = 1;
inline bool DurationRules::has_required() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DurationRules::set_has_required() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DurationRules::clear_has_required() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DurationRules::clear_required() {
  required_ = false;
  clear_has_required();
}
inline bool DurationRules::required() const {
  // @@protoc_insertion_point(field_get:validate.DurationRules.required)
  return required_;
}
inline void DurationRules::set_required(bool value) {
  set_has_required();
  required_ = value;
  // @@protoc_insertion_point(field_set:validate.DurationRules.required)
}

// optional .google.protobuf.Duration const = 2;
inline bool DurationRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DurationRules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DurationRules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DurationRules::clear_const_() {
  if (const__ != NULL) const__->::google::protobuf::Duration::Clear();
  clear_has_const_();
}
inline const ::google::protobuf::Duration& DurationRules::const_() const {
  const ::google::protobuf::Duration* p = const__;
  // @@protoc_insertion_point(field_get:validate.DurationRules.const)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::mutable_const_() {
  set_has_const_();
  if (const__ == NULL) {
    const__ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.const)
  return const__;
}
inline ::google::protobuf::Duration* DurationRules::release_const_() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.const)
  clear_has_const_();
  ::google::protobuf::Duration* temp = const__;
  const__ = NULL;
  return temp;
}
inline void DurationRules::set_allocated_const_(::google::protobuf::Duration* const_) {
  delete const__;
  if (const_ != NULL && const_->GetArena() != NULL) {
    ::google::protobuf::Duration* new_const_ = new ::google::protobuf::Duration;
    new_const_->CopyFrom(*const_);
    const_ = new_const_;
  }
  const__ = const_;
  if (const_) {
    set_has_const_();
  } else {
    clear_has_const_();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.const)
}

// optional .google.protobuf.Duration lt = 3;
inline bool DurationRules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DurationRules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DurationRules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DurationRules::clear_lt() {
  if (lt_ != NULL) lt_->::google::protobuf::Duration::Clear();
  clear_has_lt();
}
inline const ::google::protobuf::Duration& DurationRules::lt() const {
  const ::google::protobuf::Duration* p = lt_;
  // @@protoc_insertion_point(field_get:validate.DurationRules.lt)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::mutable_lt() {
  set_has_lt();
  if (lt_ == NULL) {
    lt_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.lt)
  return lt_;
}
inline ::google::protobuf::Duration* DurationRules::release_lt() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.lt)
  clear_has_lt();
  ::google::protobuf::Duration* temp = lt_;
  lt_ = NULL;
  return temp;
}
inline void DurationRules::set_allocated_lt(::google::protobuf::Duration* lt) {
  delete lt_;
  if (lt != NULL && lt->GetArena() != NULL) {
    ::google::protobuf::Duration* new_lt = new ::google::protobuf::Duration;
    new_lt->CopyFrom(*lt);
    lt = new_lt;
  }
  lt_ = lt;
  if (lt) {
    set_has_lt();
  } else {
    clear_has_lt();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.lt)
}

// optional .google.protobuf.Duration lte = 4;
inline bool DurationRules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DurationRules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DurationRules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DurationRules::clear_lte() {
  if (lte_ != NULL) lte_->::google::protobuf::Duration::Clear();
  clear_has_lte();
}
inline const ::google::protobuf::Duration& DurationRules::lte() const {
  const ::google::protobuf::Duration* p = lte_;
  // @@protoc_insertion_point(field_get:validate.DurationRules.lte)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::mutable_lte() {
  set_has_lte();
  if (lte_ == NULL) {
    lte_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.lte)
  return lte_;
}
inline ::google::protobuf::Duration* DurationRules::release_lte() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.lte)
  clear_has_lte();
  ::google::protobuf::Duration* temp = lte_;
  lte_ = NULL;
  return temp;
}
inline void DurationRules::set_allocated_lte(::google::protobuf::Duration* lte) {
  delete lte_;
  if (lte != NULL && lte->GetArena() != NULL) {
    ::google::protobuf::Duration* new_lte = new ::google::protobuf::Duration;
    new_lte->CopyFrom(*lte);
    lte = new_lte;
  }
  lte_ = lte;
  if (lte) {
    set_has_lte();
  } else {
    clear_has_lte();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.lte)
}

// optional .google.protobuf.Duration gt = 5;
inline bool DurationRules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DurationRules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DurationRules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DurationRules::clear_gt() {
  if (gt_ != NULL) gt_->::google::protobuf::Duration::Clear();
  clear_has_gt();
}
inline const ::google::protobuf::Duration& DurationRules::gt() const {
  const ::google::protobuf::Duration* p = gt_;
  // @@protoc_insertion_point(field_get:validate.DurationRules.gt)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::mutable_gt() {
  set_has_gt();
  if (gt_ == NULL) {
    gt_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.gt)
  return gt_;
}
inline ::google::protobuf::Duration* DurationRules::release_gt() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.gt)
  clear_has_gt();
  ::google::protobuf::Duration* temp = gt_;
  gt_ = NULL;
  return temp;
}
inline void DurationRules::set_allocated_gt(::google::protobuf::Duration* gt) {
  delete gt_;
  if (gt != NULL && gt->GetArena() != NULL) {
    ::google::protobuf::Duration* new_gt = new ::google::protobuf::Duration;
    new_gt->CopyFrom(*gt);
    gt = new_gt;
  }
  gt_ = gt;
  if (gt) {
    set_has_gt();
  } else {
    clear_has_gt();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.gt)
}

// optional .google.protobuf.Duration gte = 6;
inline bool DurationRules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DurationRules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DurationRules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DurationRules::clear_gte() {
  if (gte_ != NULL) gte_->::google::protobuf::Duration::Clear();
  clear_has_gte();
}
inline const ::google::protobuf::Duration& DurationRules::gte() const {
  const ::google::protobuf::Duration* p = gte_;
  // @@protoc_insertion_point(field_get:validate.DurationRules.gte)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* DurationRules::mutable_gte() {
  set_has_gte();
  if (gte_ == NULL) {
    gte_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.gte)
  return gte_;
}
inline ::google::protobuf::Duration* DurationRules::release_gte() {
  // @@protoc_insertion_point(field_release:validate.DurationRules.gte)
  clear_has_gte();
  ::google::protobuf::Duration* temp = gte_;
  gte_ = NULL;
  return temp;
}
inline void DurationRules::set_allocated_gte(::google::protobuf::Duration* gte) {
  delete gte_;
  if (gte != NULL && gte->GetArena() != NULL) {
    ::google::protobuf::Duration* new_gte = new ::google::protobuf::Duration;
    new_gte->CopyFrom(*gte);
    gte = new_gte;
  }
  gte_ = gte;
  if (gte) {
    set_has_gte();
  } else {
    clear_has_gte();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.gte)
}

// repeated .google.protobuf.Duration in = 7;
inline int DurationRules::in_size() const {
  return in_.size();
}
inline void DurationRules::clear_in() {
  in_.Clear();
}
inline const ::google::protobuf::Duration& DurationRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DurationRules.in)
  return in_.Get(index);
}
inline ::google::protobuf::Duration* DurationRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.in)
  return in_.Mutable(index);
}
inline ::google::protobuf::Duration* DurationRules::add_in() {
  // @@protoc_insertion_point(field_add:validate.DurationRules.in)
  return in_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
DurationRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.DurationRules.in)
  return &in_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
DurationRules::in() const {
  // @@protoc_insertion_point(field_list:validate.DurationRules.in)
  return in_;
}

// repeated .google.protobuf.Duration not_in = 8;
inline int DurationRules::not_in_size() const {
  return not_in_.size();
}
inline void DurationRules::clear_not_in() {
  not_in_.Clear();
}
inline const ::google::protobuf::Duration& DurationRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DurationRules.not_in)
  return not_in_.Get(index);
}
inline ::google::protobuf::Duration* DurationRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.not_in)
  return not_in_.Mutable(index);
}
inline ::google::protobuf::Duration* DurationRules::add_not_in() {
  // @@protoc_insertion_point(field_add:validate.DurationRules.not_in)
  return not_in_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
DurationRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validate.DurationRules.not_in)
  return &not_in_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
DurationRules::not_in() const {
  // @@protoc_insertion_point(field_list:validate.DurationRules.not_in)
  return not_in_;
}

// -------------------------------------------------------------------

// TimestampRules

// optional bool required = 1;
inline bool TimestampRules::has_required() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TimestampRules::set_has_required() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TimestampRules::clear_has_required() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TimestampRules::clear_required() {
  required_ = false;
  clear_has_required();
}
inline bool TimestampRules::required() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.required)
  return required_;
}
inline void TimestampRules::set_required(bool value) {
  set_has_required();
  required_ = value;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.required)
}

// optional .google.protobuf.Timestamp const = 2;
inline bool TimestampRules::has_const_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimestampRules::set_has_const_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimestampRules::clear_has_const_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimestampRules::clear_const_() {
  if (const__ != NULL) const__->::google::protobuf::Timestamp::Clear();
  clear_has_const_();
}
inline const ::google::protobuf::Timestamp& TimestampRules::const_() const {
  const ::google::protobuf::Timestamp* p = const__;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.const)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_const_() {
  set_has_const_();
  if (const__ == NULL) {
    const__ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.const)
  return const__;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_const_() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.const)
  clear_has_const_();
  ::google::protobuf::Timestamp* temp = const__;
  const__ = NULL;
  return temp;
}
inline void TimestampRules::set_allocated_const_(::google::protobuf::Timestamp* const_) {
  delete const__;
  if (const_ != NULL && const_->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_const_ = new ::google::protobuf::Timestamp;
    new_const_->CopyFrom(*const_);
    const_ = new_const_;
  }
  const__ = const_;
  if (const_) {
    set_has_const_();
  } else {
    clear_has_const_();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.const)
}

// optional .google.protobuf.Timestamp lt = 3;
inline bool TimestampRules::has_lt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimestampRules::set_has_lt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimestampRules::clear_has_lt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimestampRules::clear_lt() {
  if (lt_ != NULL) lt_->::google::protobuf::Timestamp::Clear();
  clear_has_lt();
}
inline const ::google::protobuf::Timestamp& TimestampRules::lt() const {
  const ::google::protobuf::Timestamp* p = lt_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lt)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_lt() {
  set_has_lt();
  if (lt_ == NULL) {
    lt_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.lt)
  return lt_;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_lt() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.lt)
  clear_has_lt();
  ::google::protobuf::Timestamp* temp = lt_;
  lt_ = NULL;
  return temp;
}
inline void TimestampRules::set_allocated_lt(::google::protobuf::Timestamp* lt) {
  delete lt_;
  if (lt != NULL && lt->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_lt = new ::google::protobuf::Timestamp;
    new_lt->CopyFrom(*lt);
    lt = new_lt;
  }
  lt_ = lt;
  if (lt) {
    set_has_lt();
  } else {
    clear_has_lt();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.lt)
}

// optional .google.protobuf.Timestamp lte = 4;
inline bool TimestampRules::has_lte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimestampRules::set_has_lte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimestampRules::clear_has_lte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimestampRules::clear_lte() {
  if (lte_ != NULL) lte_->::google::protobuf::Timestamp::Clear();
  clear_has_lte();
}
inline const ::google::protobuf::Timestamp& TimestampRules::lte() const {
  const ::google::protobuf::Timestamp* p = lte_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lte)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_lte() {
  set_has_lte();
  if (lte_ == NULL) {
    lte_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.lte)
  return lte_;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_lte() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.lte)
  clear_has_lte();
  ::google::protobuf::Timestamp* temp = lte_;
  lte_ = NULL;
  return temp;
}
inline void TimestampRules::set_allocated_lte(::google::protobuf::Timestamp* lte) {
  delete lte_;
  if (lte != NULL && lte->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_lte = new ::google::protobuf::Timestamp;
    new_lte->CopyFrom(*lte);
    lte = new_lte;
  }
  lte_ = lte;
  if (lte) {
    set_has_lte();
  } else {
    clear_has_lte();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.lte)
}

// optional .google.protobuf.Timestamp gt = 5;
inline bool TimestampRules::has_gt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimestampRules::set_has_gt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimestampRules::clear_has_gt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimestampRules::clear_gt() {
  if (gt_ != NULL) gt_->::google::protobuf::Timestamp::Clear();
  clear_has_gt();
}
inline const ::google::protobuf::Timestamp& TimestampRules::gt() const {
  const ::google::protobuf::Timestamp* p = gt_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gt)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_gt() {
  set_has_gt();
  if (gt_ == NULL) {
    gt_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.gt)
  return gt_;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_gt() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.gt)
  clear_has_gt();
  ::google::protobuf::Timestamp* temp = gt_;
  gt_ = NULL;
  return temp;
}
inline void TimestampRules::set_allocated_gt(::google::protobuf::Timestamp* gt) {
  delete gt_;
  if (gt != NULL && gt->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_gt = new ::google::protobuf::Timestamp;
    new_gt->CopyFrom(*gt);
    gt = new_gt;
  }
  gt_ = gt;
  if (gt) {
    set_has_gt();
  } else {
    clear_has_gt();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.gt)
}

// optional .google.protobuf.Timestamp gte = 6;
inline bool TimestampRules::has_gte() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimestampRules::set_has_gte() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimestampRules::clear_has_gte() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimestampRules::clear_gte() {
  if (gte_ != NULL) gte_->::google::protobuf::Timestamp::Clear();
  clear_has_gte();
}
inline const ::google::protobuf::Timestamp& TimestampRules::gte() const {
  const ::google::protobuf::Timestamp* p = gte_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gte)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_gte() {
  set_has_gte();
  if (gte_ == NULL) {
    gte_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.gte)
  return gte_;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_gte() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.gte)
  clear_has_gte();
  ::google::protobuf::Timestamp* temp = gte_;
  gte_ = NULL;
  return temp;
}
inline void TimestampRules::set_allocated_gte(::google::protobuf::Timestamp* gte) {
  delete gte_;
  if (gte != NULL && gte->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_gte = new ::google::protobuf::Timestamp;
    new_gte->CopyFrom(*gte);
    gte = new_gte;
  }
  gte_ = gte;
  if (gte) {
    set_has_gte();
  } else {
    clear_has_gte();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.gte)
}

// optional bool lt_now = 7;
inline bool TimestampRules::has_lt_now() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TimestampRules::set_has_lt_now() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TimestampRules::clear_has_lt_now() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TimestampRules::clear_lt_now() {
  lt_now_ = false;
  clear_has_lt_now();
}
inline bool TimestampRules::lt_now() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lt_now)
  return lt_now_;
}
inline void TimestampRules::set_lt_now(bool value) {
  set_has_lt_now();
  lt_now_ = value;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.lt_now)
}

// optional bool gt_now = 8;
inline bool TimestampRules::has_gt_now() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TimestampRules::set_has_gt_now() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TimestampRules::clear_has_gt_now() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TimestampRules::clear_gt_now() {
  gt_now_ = false;
  clear_has_gt_now();
}
inline bool TimestampRules::gt_now() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gt_now)
  return gt_now_;
}
inline void TimestampRules::set_gt_now(bool value) {
  set_has_gt_now();
  gt_now_ = value;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.gt_now)
}

// optional .google.protobuf.Duration within = 9;
inline bool TimestampRules::has_within() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TimestampRules::set_has_within() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TimestampRules::clear_has_within() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TimestampRules::clear_within() {
  if (within_ != NULL) within_->::google::protobuf::Duration::Clear();
  clear_has_within();
}
inline const ::google::protobuf::Duration& TimestampRules::within() const {
  const ::google::protobuf::Duration* p = within_;
  // @@protoc_insertion_point(field_get:validate.TimestampRules.within)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* TimestampRules::mutable_within() {
  set_has_within();
  if (within_ == NULL) {
    within_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.within)
  return within_;
}
inline ::google::protobuf::Duration* TimestampRules::release_within() {
  // @@protoc_insertion_point(field_release:validate.TimestampRules.within)
  clear_has_within();
  ::google::protobuf::Duration* temp = within_;
  within_ = NULL;
  return temp;
}
inline void TimestampRules::set_allocated_within(::google::protobuf::Duration* within) {
  delete within_;
  if (within != NULL && within->GetArena() != NULL) {
    ::google::protobuf::Duration* new_within = new ::google::protobuf::Duration;
    new_within->CopyFrom(*within);
    within = new_within;
  }
  within_ = within;
  if (within) {
    set_has_within();
  } else {
    clear_has_within();
  }
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.within)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace validate

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_validate_2eproto__INCLUDED
